import { Thread } from '../Thread.esnext';

class ThreadServiceWorkerClients {
  /**
   * Starts a listening for new clients connecting to the service worker, and
   * creates a thread around each, with the second argument as the exports of the thread.
   *
   * @example
   * ```ts
   * import {ThreadServiceWorker} from '@quilted/threads';
   *
   * // In your service worker:
   *
   * import {ThreadServiceWorkerClients} from '@quilted/threads';
   *
   * ThreadServiceWorkerClients.export({
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   *
   * // On the main thread:
   *
   * const registration = await navigator.serviceWorker.register('worker.js');
   * const serviceWorker = registration.installing ?? registration.waiting ?? registration.active;
   * const {getMessage} = ThreadServiceWorker.import(serviceWorker);
   * const message = await getMessage(); // 'Hello, world!'
   * ```
   */
  static export(exports, options) {
    new ThreadServiceWorkerClients({ ...options, exports });
  }
  #threads = /* @__PURE__ */ new WeakMap();
  #listeners = /* @__PURE__ */ new WeakMap();
  #options;
  constructor(options = {}) {
    const serviceWorker = self;
    serviceWorker.addEventListener("message", (event) => {
      const source = event.source;
      if (source == null) return;
      if (options.include != null && !options.include(source)) return;
      this.#createForClient(source);
      this.#listeners.get(source)?.(event.data);
    });
    this.#options = options;
  }
  get(client) {
    return this.#threads.get(client);
  }
  delete(client) {
    return this.#threads.delete(client);
  }
  create(client, overrideOptions) {
    return this.#createForClient(client, overrideOptions);
  }
  #createForClient(source, overrideOptions) {
    let thread = this.#threads.get(source);
    if (thread) return thread;
    thread = new Thread(
      {
        listen(listener, { signal }) {
          self.addEventListener(
            "message",
            (event) => {
              if (event.source !== source) return;
              listener(event.data);
            },
            { signal }
          );
        },
        send(message, transfer = []) {
          source.postMessage(message, transfer);
        }
      },
      {
        ...this.#options,
        ...overrideOptions
      }
    );
    this.#threads.set(source, thread);
    return thread;
  }
}

export { ThreadServiceWorkerClients };
