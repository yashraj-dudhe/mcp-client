import { Thread } from '../../Thread.esnext';
import { RESPONSE_MESSAGE, CHECK_MESSAGE } from './shared.esnext';

class ThreadWindow extends Thread {
  window;
  /**
   * Starts a thread wrapped around a `window` object, and returns the imports
   * of the thread.
   *
   * @example
   * ```ts
   * import {ThreadWindow} from '@quilted/threads';
   *
   * const {getMessage} = ThreadWindow.import(window);
   * const message = await getMessage(); // 'Hello, world!'
   *
   * // In the nested window:
   *
   * import {ThreadNestedWindow} from '@quilted/threads';
   *
   * ThreadNestedWindow.export(window.opener, {
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   * ```
   */
  static import(window, options) {
    return new ThreadWindow(window, options).imports;
  }
  /**
   * Starts a thread wrapped around a `window` object, providing the second
   * argument as the exports of the thread.
   *
   * @example
   * ```ts
   * import {ThreadWindow} from '@quilted/threads';
   *
   * ThreadWindow.export(window, {
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   *
   * // In the nested window:
   *
   * import {ThreadNestedWindow} from '@quilted/threads';
   *
   * const {getMessage} = ThreadNestedWindow.import(window.opener);
   * const message = await getMessage(); // 'Hello, world!'
   * ```
   */
  static export(window, exports, options) {
    new ThreadWindow(window, { ...options, exports });
  }
  constructor(window, {
    targetOrigin = "*",
    ...options
  } = {}) {
    super(windowToThreadTarget(window, { targetOrigin }), options);
    this.window = window;
  }
}
function windowToThreadTarget(window, { targetOrigin = "*" } = {}) {
  let connected = false;
  const sendMessage = function send(message, transfer) {
    window.postMessage(message, targetOrigin, transfer);
  };
  const connectedPromise = new Promise((resolve) => {
    const abort = new AbortController();
    globalThis.window.addEventListener(
      "message",
      (event) => {
        if (event.source !== window) return;
        if (event.data === RESPONSE_MESSAGE) {
          connected = true;
          abort.abort();
          resolve();
        }
      },
      { signal: abort.signal }
    );
    abort.signal.addEventListener("abort", () => resolve(), { once: true });
    sendMessage(CHECK_MESSAGE);
  });
  return {
    send(message, transfer) {
      if (!connected) {
        return connectedPromise.then(() => {
          if (connected) return sendMessage(message, transfer);
        });
      }
      return sendMessage(message, transfer);
    },
    listen(listen, { signal }) {
      self.addEventListener(
        "message",
        (event) => {
          if (event.source !== window) return;
          if (event.data === RESPONSE_MESSAGE) return;
          listen(event.data);
        },
        { signal }
      );
    }
  };
}

export { ThreadWindow, windowToThreadTarget };
