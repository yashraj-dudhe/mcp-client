import { MESSAGE_FUNCTION_CALL, MESSAGE_FUNCTION_RELEASE } from '../constants.esnext';
import { nanoid } from '../nanoid.esnext';

class ThreadFunctionsAutomatic {
  #functionsToId = /* @__PURE__ */ new Map();
  #idsToFunction = /* @__PURE__ */ new Map();
  #idsToProxy = /* @__PURE__ */ new Map();
  #finalization = /* @__PURE__ */ new WeakMap();
  get(id) {
    return this.#idsToFunction.get(id);
  }
  release(id) {
    const func = this.#idsToFunction.get(id);
    if (func) {
      this.#idsToFunction.delete(id);
      this.#functionsToId.delete(func);
    }
    return Boolean(func);
  }
  serialize(func) {
    let id = this.#functionsToId.get(func);
    if (id == null) {
      id = nanoid();
      this.#functionsToId.set(func, id);
      this.#idsToFunction.set(id, func);
    }
    return id;
  }
  deserialize(id, thread) {
    let proxy = this.#idsToProxy.get(id)?.deref();
    if (proxy) return proxy;
    proxy = (...args) => {
      if (!this.#idsToProxy.has(id)) {
        throw new Error(
          "You attempted to call a function that was already revoked."
        );
      }
      return thread.call((callID, args2, transferable) => {
        thread.messages.send(
          [MESSAGE_FUNCTION_CALL, callID, id, args2],
          transferable
        );
      }, args);
    };
    this.#finalizationRegistry(thread)?.register(proxy, id);
    this.#idsToProxy.set(id, new WeakRef(proxy));
    return proxy;
  }
  #finalizationRegistry(thread) {
    let finalization = this.#finalization.get(thread);
    if (typeof FinalizationRegistry === "undefined") {
      return void 0;
    }
    if (!finalization) {
      finalization = new FinalizationRegistry((id) => {
        thread.messages.send([MESSAGE_FUNCTION_RELEASE, id]);
      });
      this.#finalization.set(thread, finalization);
    }
    return finalization;
  }
}

export { ThreadFunctionsAutomatic };
