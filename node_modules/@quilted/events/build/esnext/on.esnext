import { addEventHandler } from './handler.esnext';
import { AbortError } from './abort/AbortError.esnext';
import { NestedAbortController } from './abort/NestedAbortController.esnext';

function on(target, event, options) {
  const signal = options?.signal;
  const abortBehavior = options?.abort ?? "resolve";
  if (signal?.aborted) {
    if (abortBehavior === "resolve") {
      return noop();
    } else {
      return noopThrow(new AbortError());
    }
  }
  const listenerAbortController = signal ? new NestedAbortController(signal) : new AbortController();
  const signalAbortController = signal && new AbortController();
  const unconsumedEvents = [];
  const unconsumedPromises = [];
  let error = null;
  let finished = false;
  const asyncDispose = Symbol.asyncDispose ?? Symbol("asyncDispose");
  const iterator = {
    next() {
      const value = unconsumedEvents.shift();
      if (value) {
        return Promise.resolve({ value, done: false });
      }
      if (error) {
        const promise = Promise.reject(error);
        error = null;
        return promise;
      }
      if (finished) {
        return Promise.resolve({ value: void 0, done: true });
      }
      return new Promise(function(resolve, reject) {
        unconsumedPromises.push({ resolve, reject });
      });
    },
    return() {
      listenerAbortController.abort();
      signalAbortController?.abort();
      finished = true;
      for (const promise of unconsumedPromises) {
        promise.resolve({ value: void 0, done: true });
      }
      return Promise.resolve({ value: void 0, done: true });
    },
    throw(err) {
      error = err;
      listenerAbortController.abort();
      return Promise.reject(error);
    },
    [Symbol.asyncIterator]() {
      return this;
    },
    async [asyncDispose]() {
    }
  };
  addEventHandler(target, event, eventHandler, {
    signal: listenerAbortController.signal
  });
  if (signal) {
    addEventHandler(signal, "abort", abortListener, {
      once: true,
      signal: signalAbortController.signal
    });
  }
  return iterator;
  function abortListener() {
    if (abortBehavior === "resolve") {
      iterator.return();
    } else {
      handleError(new AbortError());
    }
  }
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    const normalizedArgs = args.length > 1 ? args : args[0];
    if (promise) {
      promise.resolve({ value: normalizedArgs, done: false });
    } else {
      unconsumedEvents.push(normalizedArgs);
    }
  }
  function handleError(err) {
    finished = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error = err;
    }
    iterator.return();
  }
}
async function* noop() {
}
async function* noopThrow(error) {
  throw error;
}

export { on };
