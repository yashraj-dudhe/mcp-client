import { on } from './on.esnext';
import { once } from './once.esnext';
import { addEventHandler } from './handler.esnext';

class EventEmitter {
  /**
   * A map containing the event handlers registered for events on this
   * emitter. You should not directly mutate this map, but you can use it
   * to introspect the number of handlers currently registered.
   */
  all = /* @__PURE__ */ new Map();
  /**
   * A reference to an `EventTarget` that is being wrapped with this `EventEmitter`.
   * As handlers are added for events on the emitter, matching events are listened
   * for lazily on the `EventTarget`. This is useful for converting event producers
   * in existing environments into objects that can be used with `once()` and `on()`.
   *
   * @example
   * const button = document.querySelector('button');
   * const emitter = new EventEmitter(button);
   * // emitter.eventTarget === button
   *
   * const click = await emitter.once('click');
   * console.log('clicked!', click);
   */
  eventTarget;
  /**
   * An `EventEmitter` that triggers events when handlers are added
   * or removed from this emitter. This is useful for debugging, and for
   * building higher-level abstractions that need to know when handlers
   * are registered for a given event.
   */
  get internal() {
    if (this._internal) {
      return this._internal;
    } else {
      const internal = new EventEmitter();
      this._internal = internal;
      return internal;
    }
  }
  _internal;
  handleEvent = (event, handler, options) => {
    const signal = options?.signal;
    const once = options?.once;
    let handlers = this.all.get(event);
    const signalAbort = signal && new AbortController();
    const remove = () => {
      signalAbort?.abort();
      if (handlers == null) return;
      this._internal?.emit("remove", { event, all: handlers, handler });
      handlers.delete(handler);
      if (handlers.size === 0) this.all.delete(event);
    };
    const normalizedHandler = once ? (...args) => {
      remove();
      handler(...args);
    } : handler;
    if (handlers) {
      handlers.add(normalizedHandler);
    } else {
      handlers = /* @__PURE__ */ new Set();
      handlers.add(normalizedHandler);
      this.all.set(event, handlers);
    }
    this._internal?.emit("add", { event, all: handlers, handler });
    signal?.addEventListener("abort", remove, { signal: signalAbort.signal });
  };
  constructor(eventTarget) {
    this.on = this.on.bind(this);
    this.once = this.once.bind(this);
    this.emit = this.emit.bind(this);
    if (eventTarget) {
      this.eventTarget = eventTarget;
      const abortMap = /* @__PURE__ */ new Map();
      this.internal.on("add", ({ event: eventName, all }) => {
        if (all.size !== 1) return;
        const abort = new AbortController();
        abortMap.set(eventName, abort);
        addEventHandler(
          eventTarget,
          eventName,
          (event) => {
            this.emit(eventName, event);
          },
          {
            signal: abort.signal
          }
        );
      });
      this.internal.on("remove", ({ event: eventName, all }) => {
        const abort = all.size === 0 ? abortMap.get(eventName) : void 0;
        if (abort == null) return;
        abort.abort();
        abortMap.delete(eventName);
      });
    }
  }
  on(event, argOne, argTwo) {
    return typeof argOne === "function" ? this.handleEvent(event, argOne, argTwo) : on(this.handleEvent, event, argOne);
  }
  once(event, argOne, argTwo) {
    return typeof argOne === "function" ? this.handleEvent(event, argOne, { ...argTwo, once: true }) : once(this.handleEvent, event, argOne);
  }
  /**
   * Emits an event with the given `data`. This will trigger all handlers
   * listening for the provided `event`.
   */
  emit(event, data) {
    const handlers = this.all.get(event);
    if (handlers) {
      for (const handler of Array.from(handlers)) {
        handler(data);
      }
    }
  }
}
function createEventEmitter() {
  return new EventEmitter();
}

export { EventEmitter, createEventEmitter };
