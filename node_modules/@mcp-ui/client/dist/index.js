(function(E,m){typeof exports=="object"&&typeof module<"u"?m(exports,require("react/jsx-runtime"),require("react")):typeof define=="function"&&define.amd?define(["exports","react/jsx-runtime","react"],m):(E=typeof globalThis<"u"?globalThis:E||self,m(E.McpUiClient={},E.jsxRuntime,E.React))})(this,function(E,m,_){"use strict";var pt=Object.defineProperty;var Se=E=>{throw TypeError(E)};var mt=(E,m,_)=>m in E?pt(E,m,{enumerable:!0,configurable:!0,writable:!0,value:_}):E[m]=_;var O=(E,m,_)=>mt(E,typeof m!="symbol"?m+"":m,_),ee=(E,m,_)=>m.has(E)||Se("Cannot "+_);var v=(E,m,_)=>(ee(E,m,"read from private field"),_?_.call(E):m.get(E)),w=(E,m,_)=>m.has(E)?Se("Cannot add the same private member more than once"):m instanceof WeakSet?m.add(E):m.set(E,_),H=(E,m,_,Y)=>(ee(E,m,"write to private field"),Y?Y.call(E,_):m.set(E,_),_),y=(E,m,_)=>(ee(E,m,"access private method"),_);var C,A,D,F,W,Me,z,L,T,q,N,I,M,g,te,Ne,re,Ae;function Y(n){const e=typeof n.uri=="string"&&n.uri.startsWith("ui-app://"),t=e?"text/uri-list":n.mimeType;if(t!=="text/html"&&t!=="text/uri-list")return{error:"Resource must be of type text/html (for HTML content) or text/uri-list (for URL content)."};if(t==="text/uri-list"){let r="";if(typeof n.text=="string"&&n.text.trim()!=="")r=n.text;else if(typeof n.blob=="string")try{r=new TextDecoder().decode(Uint8Array.from(atob(n.blob),o=>o.charCodeAt(0)))}catch(o){return console.error("Error decoding base64 blob for URL content:",o),{error:"Error decoding URL from blob."}}else return{error:"URL resource expects a non-empty text or blob field containing the URL."};if(r.trim()==="")return{error:"URL content is empty."};const i=r.split(`
`).map(o=>o.trim()).filter(o=>o&&!o.startsWith("#"));return i.length===0?{error:"No valid URLs found in uri-list content."}:(i.length>1&&console.warn(`Multiple URLs found in uri-list content. Using the first URL: "${i[0]}". Other URLs ignored:`,i.slice(1)),e&&console.warn(`Detected legacy ui-app:// URI: "${n.uri}". Update server to use ui:// with mimeType: 'text/uri-list' for future compatibility.`),{iframeSrc:i[0],iframeRenderMode:"src"})}else if(t==="text/html"){if(typeof n.text=="string")return{htmlString:n.text,iframeRenderMode:"srcDoc"};if(typeof n.blob=="string")try{return{htmlString:new TextDecoder().decode(Uint8Array.from(atob(n.blob),i=>i.charCodeAt(0))),iframeRenderMode:"srcDoc"}}catch(r){return console.error("Error decoding base64 blob for HTML content:",r),{error:"Error decoding HTML content from blob."}}else return{error:"HTML resource requires text or blob content."}}else return{error:"Unsupported mimeType. Expected text/html or text/uri-list."}}const B=_.forwardRef(({resource:n,onUiAction:e,style:t,iframeProps:r},i)=>{const o=_.useRef(null);_.useImperativeHandle(i,()=>o.current);const{error:a,iframeSrc:p,iframeRenderMode:d,htmlString:h}=_.useMemo(()=>Y(n),[n]);return _.useEffect(()=>{function s(c){var l;if(o.current&&c.source===o.current.contentWindow){const u=c.data;if(!u)return;(l=e==null?void 0:e(u))==null||l.catch(f=>{console.error("Error handling UI action result in RenderHtmlResource:",f)})}}return window.addEventListener("message",s),()=>window.removeEventListener("message",s)},[e]),a?m.jsx("p",{className:"text-red-500",children:a}):d==="srcDoc"?h==null?a?null:m.jsx("p",{className:"text-orange-500",children:"No HTML content to display."}):m.jsx("iframe",{srcDoc:h,sandbox:"allow-scripts",style:{width:"100%",minHeight:200,...t},title:"MCP HTML Resource (Embedded Content)",...r,ref:o}):d==="src"?p==null?a?null:m.jsx("p",{className:"text-orange-500",children:"No URL provided for HTML resource."}):m.jsx("iframe",{src:p,sandbox:"allow-scripts allow-same-origin",style:{width:"100%",minHeight:200,...t},title:"MCP HTML Resource (URL)",...r,ref:o}):m.jsx("p",{className:"text-gray-500",children:"Initializing HTML resource display..."})});B.displayName="HtmlResource";const ne=1,oe=3,ie=8,Ie=9,Oe=0,Ce=1,De=2,ze=3,k=1,$=2,K=3,j="~";function se({call:n,insertChild:e,removeChild:t,updateText:r,updateProperty:i}){const o={[Oe]:e,[Ce]:t,[De]:r,[ze]:i};return{call:n,mutate(a){for(const[p,...d]of a)o[p](...d)}}}class Le{constructor({retain:e,release:t,methods:r}={}){O(this,"root",{id:j,type:Ie,children:[],version:0,properties:{},attributes:{},eventListeners:{}});O(this,"attached",new Map([[j,this.root]]));O(this,"subscribers",new Map);O(this,"parents",new Map);O(this,"implementations",new Map);const{attached:i,parents:o,subscribers:a}=this;this.connection=se({call:(s,c,...l)=>{const u=this.implementations.get(s),f=u==null?void 0:u[c];if(typeof f!="function")throw new Error(`Node ${s} does not implement the ${c}() method`);return f(...l)},insertChild:(s,c,l)=>{const u=i.get(s),{children:f}=u,b=d(c,u);l===f.length?f.push(b):f.splice(l,0,b),u.version+=1,this.parents.set(c.id,u.id),p(u)},removeChild:(s,c)=>{const l=i.get(s),{children:u}=l,[f]=u.splice(c,1);f&&(l.version+=1,p(l),h(f))},updateProperty:(s,c,l,u=k)=>{const f=i.get(s);e==null||e(l);let b;switch(u){case k:b=f.properties;break;case $:b=f.attributes;break;case K:b=f.eventListeners;break}const P=b[c];b[c]=l,f.version+=1;let R;if(c==="slot"){const S=this.parents.get(s);R=S==null?S:i.get(S),R&&(R.version+=1)}p(f),R&&p(R),t==null||t(P)},updateText:(s,c)=>{const l=i.get(s);l.data=c,l.version+=1,p(l)}}),r&&this.implement(this.root,r);function p(s){const c=a.get(s.id);if(c)for(const l of c)l(s)}function d(s,c){let l;switch(s.type){case oe:case ie:{const{id:u,type:f,data:b}=s;l={id:u,type:f,data:b,version:0};break}case ne:{const{id:u,type:f,element:b,children:P,properties:R,attributes:S,eventListeners:U}=s;e==null||e(R),e==null||e(U);const x=[];l={id:u,type:f,element:b,version:0,children:x,properties:{...R},attributes:{...S},eventListeners:{...U}};for(const ut of P)x.push(d(ut,l));break}default:throw new Error(`Unknown node type: ${JSON.stringify(s)}`)}return i.set(l.id,l),o.set(l.id,c.id),l}function h(s){if(i.delete(s.id),o.delete(s.id),t&&("properties"in s&&t(s.properties),"eventListeners"in s&&t(s.eventListeners)),"children"in s)for(const c of s.children)h(c)}}get({id:e}){return this.attached.get(e)}implement({id:e},t){t==null?this.implementations.delete(e):this.implementations.set(e,t)}subscribe({id:e},t,{signal:r}={}){let i=this.subscribers.get(e);i==null&&(i=new Set,this.subscribers.set(e,i)),i.add(t),r==null||r.addEventListener("abort",()=>{i.delete(t),i.size===0&&this.subscribers.delete(e)})}}const ae=new WeakMap,G=new WeakMap,le=new WeakMap;class Ue{constructor({root:e,retain:t,release:r,call:i,cache:o}={}){O(this,"attached",new Map);this.root=e??document.createDocumentFragment();const{attached:a}=this,p=new Map;this.connection=se({call:(s,c,...l)=>{const u=s===j&&this.root.nodeType!==11?this.root:a.get(s);return i?i(u,c,...l):u[c](...l)},insertChild:(s,c,l)=>{const u=s===j?this.root:a.get(s),f=p.get(s);f&&clearTimeout(f),u.insertBefore(d(c),u.childNodes[l]||null)},removeChild:(s,c)=>{const u=(s===j?this.root:a.get(s)).childNodes[c];if(u.remove(),o!=null&&o.maxAge){const f=p.get(s);f&&clearTimeout(f);const b=setTimeout(()=>{h(u)},o.maxAge);p.set(s,b)}else h(u)},updateProperty:(s,c,l,u=k)=>{const f=a.get(s);t==null||t(l);const b=G.get(f),P=b[c];b[c]=l,V(f,c,l,u),r==null||r(P)},updateText:(s,c)=>{const l=a.get(s);l.data=c}});function d(s){const c=a.get(s.id);if(c)return c;let l;switch(s.type){case ne:{if(l=document.createElement(s.element),s.properties){G.set(l,s.properties);for(const u of Object.keys(s.properties)){const f=s.properties[u];t==null||t(f),V(l,u,f,k)}}else G.set(l,{});if(s.attributes)for(const u of Object.keys(s.attributes)){const f=s.attributes[u];t==null||t(f),V(l,u,f,$)}if(le.set(l,{}),s.eventListeners)for(const u of Object.keys(s.eventListeners)){const f=s.eventListeners[u];t==null||t(f),V(l,u,f,K)}for(const u of s.children)l.appendChild(d(u));break}case oe:{l=document.createTextNode(s.data);break}case ie:{l=document.createComment(s.data);break}default:throw new Error(`Unknown node type: ${JSON.stringify(s)}`)}return ae.set(l,s.id),a.set(s.id,l),l}function h(s){const c=ae.get(s);c&&a.delete(c);const l=G.get(s);if(l&&r&&r(l),s instanceof Element)for(const u of s.childNodes)h(u)}}connect(e){const t=this.root;this.root=e,t.childNodes.forEach(r=>{e.appendChild(r)})}disconnect(){if(this.root.nodeType===11)return this.root;const e=this.root,t=new DocumentFragment;return this.root=t,e.childNodes.forEach(r=>{t.appendChild(r)}),t}}function V(n,e,t,r){switch(r){case k:{n[e]=t;break}case $:{t==null?n.removeAttribute(e):n.setAttribute(e,t);break}case K:{const i=le.get(n),o=i==null?void 0:i[e];if(o&&n.removeEventListener(e,o),t!=null){const a=p=>{var h;if(p.target!==n)return;const d=t(p.detail);(h=p.resolve)==null||h.call(p,d)};i&&(i[e]=a),n.addEventListener(e,a)}break}}}function Z(n,e){const[t,r]=_.useState(()=>{const o=e.get(n);return{id:n.id,version:o==null?void 0:o.version,value:o,receiver:e}});let i=t.value;if(t.receiver!==e||t.id!==n.id){const o=e.get(n);i=o,r({receiver:e,id:n.id,version:o==null?void 0:o.version,value:i})}return _.useDebugValue(i),_.useEffect(()=>{const o=new AbortController,a=()=>{o.signal.aborted||r(p=>{const{id:d,version:h,receiver:s}=p,{id:c}=n;if(s!==e||d!==c)return p;const l=e.get(n),u=l==null?void 0:l.version;return h===u?p:{receiver:e,value:l,id:c,version:u}})};return e.subscribe(n,a,{signal:o.signal}),a(),()=>{o.abort()}},[e,n.id]),i}function xe({remote:n,receiver:e}){const t=Z(n,e);return t?m.jsx(m.Fragment,{children:t.data}):null}function J(n,{receiver:e,components:t}){switch(n.type){case 1:{const r=t.get(n.element);if(r==null)throw new Error(`No component found for remote element: ${n.element}`);return m.jsx(r,{element:n,receiver:e,components:t},n.id)}case 3:return m.jsx(xe,{remote:n,receiver:e},n.id);case 8:return null;default:throw new Error(`Unknown remote node type: ${String(n)}`)}}function ke(n,e){if(!n)return;const{children:t,properties:r,attributes:i,eventListeners:o}=n,a=[],p={...r,...i,children:a};if(e.eventProps)for(const[d,h]of Object.entries(e.eventProps)){const s=h==null?void 0:h.event;if(s==null)continue;const c=o[s];c&&(p[d]=ce(c))}else for(const[d,h]of Object.entries(o))p[`on${d[0].toUpperCase()}${d.slice(1)}`]=ce(h);for(const d of t)if(d.type===1&&typeof d.attributes.slot=="string"){const h=d.attributes.slot,s=J(d,e);p[h]=p[h]?m.jsxs(m.Fragment,{children:[p[h],s]}):s}else a.push(J(d,e));return p}function ce(n){return function(...t){if(t.length===1&&t[0]instanceof Event){const r=t[0];return r.target!==r.currentTarget?void 0:"detail"in r?n(r.detail):n()}return n(...t)}}const je=Symbol.for("remote-dom.element"),Fe=Symbol.for("remote-dom.element.attached");function Ye(n,{name:e,eventProps:t}={}){const r=_.memo(function({element:o,receiver:a,components:p}){const d=_.useRef(),h=Z(o,a),s=h??o,c=s.id,l=ke(s,{receiver:a,components:p,eventProps:t});if(l[je]=s,l[Fe]=h!=null,d.current==null){const u={id:c,receiver:a};u.instanceRef=Ge(u),d.current=u}return d.current.id=c,d.current.receiver=a,_.useEffect(()=>{var f;const u={id:c};return a.implement(u,(f=d.current)==null?void 0:f.instanceRef.current),()=>{a.implement(u,null)}},[c,a]),m.jsx(n,{ref:d.current.instanceRef,...l})});return r.displayName=e??`RemoteComponentRenderer(${n.displayName??n.name??"Component"})`,r}function Ge(n){let e=null;return{get current(){return e},set current(t){e=t,n.receiver.implement(n,t)}}}function Ve(n){const{receiver:e}=n,{children:t}=Z(e.root,e);return m.jsx(m.Fragment,{children:t.map(r=>J(r,n))})}const We=`<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
</head>
<body>
  <div id="root"></div>
  <script>
"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteEvent.mjs
  var RemoteEvent = class extends CustomEvent {
    /**
     * The last value received from a \`respondWith()\` call.
     */
    /**
     * Provides the \`response\` value to be sent as the return value for
     * the remote property function that triggered this event.
     */
    respondWith(response) {
      this.response = response;
    }
  };

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/constants.mjs
  var MUTATION_TYPE_INSERT_CHILD = 0;
  var MUTATION_TYPE_REMOVE_CHILD = 1;
  var MUTATION_TYPE_UPDATE_TEXT = 2;
  var MUTATION_TYPE_UPDATE_PROPERTY = 3;
  var UPDATE_PROPERTY_TYPE_PROPERTY = 1;
  var UPDATE_PROPERTY_TYPE_ATTRIBUTE = 2;
  var UPDATE_PROPERTY_TYPE_EVENT_LISTENER = 3;
  var ROOT_ID = "~";

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/internals.mjs
  var REMOTE_CONNECTIONS = /* @__PURE__ */ new WeakMap();
  var REMOTE_IDS = /* @__PURE__ */ new WeakMap();
  var id = 0;
  function remoteId(node) {
    let remoteID = REMOTE_IDS.get(node);
    if (remoteID == null) {
      remoteID = String(id++);
      REMOTE_IDS.set(node, remoteID);
    }
    return remoteID;
  }
  var REMOTE_PROPERTIES = /* @__PURE__ */ new WeakMap();
  function remoteProperties(node) {
    return REMOTE_PROPERTIES.get(node);
  }
  var REMOTE_ATTRIBUTES = /* @__PURE__ */ new WeakMap();
  function remoteAttributes(node) {
    let attributes = REMOTE_ATTRIBUTES.get(node);
    if (attributes != null) return attributes;
    if (!(node instanceof Element) || node.tagName.includes("-")) return void 0;
    attributes = {};
    for (const {
      name,
      value
    } of node.attributes) {
      attributes[name] = value;
    }
    return attributes;
  }
  var REMOTE_EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
  function remoteEventListeners(node) {
    return REMOTE_EVENT_LISTENERS.get(node);
  }
  function updateRemoteElementProperty(node, property, value) {
    let properties = REMOTE_PROPERTIES.get(node);
    if (properties == null) {
      properties = {};
      REMOTE_PROPERTIES.set(node, properties);
    }
    if (properties[property] === value) return;
    properties[property] = value;
    const connection = REMOTE_CONNECTIONS.get(node);
    if (connection == null) return;
    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), property, value, UPDATE_PROPERTY_TYPE_PROPERTY]]);
  }
  function updateRemoteElementAttribute(node, attribute, value) {
    let attributes = REMOTE_ATTRIBUTES.get(node);
    if (attributes == null) {
      attributes = {};
      REMOTE_ATTRIBUTES.set(node, attributes);
    }
    if (attributes[attribute] === value) return;
    if (value == null) {
      delete attributes[attribute];
    } else {
      attributes[attribute] = String(value);
    }
    const connection = REMOTE_CONNECTIONS.get(node);
    if (connection == null) return;
    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), attribute, value, UPDATE_PROPERTY_TYPE_ATTRIBUTE]]);
  }
  function updateRemoteElementEventListener(node, event, listener) {
    let eventListeners = REMOTE_EVENT_LISTENERS.get(node);
    if (eventListeners == null) {
      eventListeners = {};
      REMOTE_EVENT_LISTENERS.set(node, eventListeners);
    }
    if (eventListeners[event] === listener) return;
    if (listener == null) {
      delete eventListeners[event];
    } else {
      eventListeners[event] = listener;
    }
    const connection = REMOTE_CONNECTIONS.get(node);
    if (connection == null) return;
    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), event, listener, UPDATE_PROPERTY_TYPE_EVENT_LISTENER]]);
  }
  function connectRemoteNode(node, connection) {
    const existingConnection = REMOTE_CONNECTIONS.get(node);
    if (existingConnection === connection) return;
    REMOTE_CONNECTIONS.set(node, connection);
    if (node.childNodes) {
      for (let i = 0; i < node.childNodes.length; i++) {
        connectRemoteNode(node.childNodes[i], connection);
      }
    }
  }
  function disconnectRemoteNode(node) {
    const existingConnection = REMOTE_CONNECTIONS.get(node);
    if (existingConnection == null) return;
    REMOTE_CONNECTIONS.delete(node);
    if (node.childNodes) {
      for (let i = 0; i < node.childNodes.length; i++) {
        disconnectRemoteNode(node.childNodes[i]);
      }
    }
  }
  function serializeRemoteNode(node) {
    const {
      nodeType
    } = node;
    switch (nodeType) {
      // Element
      case 1: {
        return {
          id: remoteId(node),
          type: nodeType,
          element: node.localName,
          properties: cloneMaybeObject(remoteProperties(node)),
          attributes: cloneMaybeObject(remoteAttributes(node)),
          eventListeners: cloneMaybeObject(remoteEventListeners(node)),
          children: Array.from(node.childNodes).map(serializeRemoteNode)
        };
      }
      // TextNode
      case 3:
      // Comment
      // eslint-disable-next-line no-fallthrough
      case 8: {
        return {
          id: remoteId(node),
          type: nodeType,
          data: node.data
        };
      }
      default: {
        throw new Error(\`Cannot serialize node of type \${node.nodeType} (\${typeof node.nodeType})\`);
      }
    }
  }
  function cloneMaybeObject(maybeObject) {
    return maybeObject ? {
      ...maybeObject
    } : void 0;
  }
  function callRemoteElementMethod(node, method, ...args) {
    const id2 = REMOTE_IDS.get(node);
    const connection = REMOTE_CONNECTIONS.get(node);
    if (id2 == null || connection == null) {
      throw new Error(\`Cannot call method \${method} on an unconnected node\`);
    }
    return connection.call(id2, method, ...args);
  }

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteElement.mjs
  var EMPTY_DEFINITION = Object.freeze({});
  var RemoteElement = class extends HTMLElement {
    static get observedAttributes() {
      return this.finalize().__observedAttributes;
    }
    /**
     * The resolved property definitions for this remote element.
     */
    static get remotePropertyDefinitions() {
      return this.finalize().__remotePropertyDefinitions;
    }
    /**
     * The resolved attribute definitions for this remote element.
     */
    static get remoteAttributeDefinitions() {
      return this.finalize().__remoteAttributeDefinitions;
    }
    /**
     * The resolved event listener definitions for this remote element.
     */
    static get remoteEventDefinitions() {
      return this.finalize().__remoteEventDefinitions;
    }
    /**
     * The resolved slot definitions for this remote element.
     */
    static get remoteSlotDefinitions() {
      return this.finalize().__remoteSlotDefinitions;
    }
    /**
     * Creates a new definition for a property that will be synchronized between
     * this remote element and its host representation.
     */
    static createProperty(name, definition) {
      saveRemoteProperty(name, definition, this.observedAttributes, this.remotePropertyDefinitions, this.__attributeToPropertyMap, this.__eventToPropertyMap);
    }
    /**
     * Consumes all the static members defined on the class and converts them
     * into the internal representation used to handle properties, attributes,
     * and event listeners.
     */
    static finalize() {
      if (this.hasOwnProperty("__finalized")) {
        return this;
      }
      this.__finalized = true;
      const {
        slottable,
        remoteSlots,
        remoteProperties: remoteProperties2,
        remoteAttributes: remoteAttributes2,
        remoteEvents,
        remoteMethods
      } = this;
      const SuperConstructor = Object.getPrototypeOf(this);
      const observedAttributes = /* @__PURE__ */ new Set();
      if (slottable) observedAttributes.add("slot");
      const attributeToPropertyMap = /* @__PURE__ */ new Map();
      const eventToPropertyMap = /* @__PURE__ */ new Map();
      const remoteSlotDefinitions = /* @__PURE__ */ new Map();
      const remotePropertyDefinitions = /* @__PURE__ */ new Map();
      const remoteAttributeDefinitions = /* @__PURE__ */ new Map();
      const remoteEventDefinitions = /* @__PURE__ */ new Map();
      if (typeof SuperConstructor.finalize === "function") {
        SuperConstructor.finalize();
        SuperConstructor.observedAttributes.forEach((attribute) => {
          observedAttributes.add(attribute);
        });
        SuperConstructor.remotePropertyDefinitions.forEach((definition, property) => {
          remotePropertyDefinitions.set(property, definition);
        });
        SuperConstructor.remoteAttributeDefinitions.forEach((definition, event) => {
          remoteAttributeDefinitions.set(event, definition);
        });
        SuperConstructor.remoteEventDefinitions.forEach((definition, event) => {
          remoteEventDefinitions.set(event, definition);
        });
        SuperConstructor.remoteSlotDefinitions.forEach((definition, slot) => {
          remoteSlotDefinitions.set(slot, definition);
        });
      }
      if (remoteSlots != null) {
        const slotNames = Array.isArray(remoteSlots) ? remoteSlots : Object.keys(remoteSlots);
        slotNames.forEach((slotName) => {
          remoteSlotDefinitions.set(slotName, EMPTY_DEFINITION);
        });
      }
      if (remoteProperties2 != null) {
        if (Array.isArray(remoteProperties2)) {
          remoteProperties2.forEach((propertyName) => {
            saveRemoteProperty(propertyName, void 0, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);
          });
        } else {
          Object.keys(remoteProperties2).forEach((propertyName) => {
            saveRemoteProperty(propertyName, remoteProperties2[propertyName], observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);
          });
        }
      }
      if (remoteAttributes2 != null) {
        remoteAttributes2.forEach((attribute) => {
          remoteAttributeDefinitions.set(attribute, EMPTY_DEFINITION);
          observedAttributes.add(attribute);
        });
      }
      if (remoteEvents != null) {
        if (Array.isArray(remoteEvents)) {
          remoteEvents.forEach((event) => {
            remoteEventDefinitions.set(event, EMPTY_DEFINITION);
          });
        } else {
          Object.keys(remoteEvents).forEach((event) => {
            remoteEventDefinitions.set(event, remoteEvents[event]);
          });
        }
      }
      if (remoteMethods != null) {
        if (Array.isArray(remoteMethods)) {
          for (const method of remoteMethods) {
            this.prototype[method] = function(...args) {
              return this.callRemoteMethod(method, ...args);
            };
          }
        } else {
          Object.assign(this, remoteMethods);
        }
      }
      Object.defineProperties(this, {
        __observedAttributes: {
          value: [...observedAttributes],
          enumerable: false
        },
        __remoteSlotDefinitions: {
          value: remoteSlotDefinitions,
          enumerable: false
        },
        __remotePropertyDefinitions: {
          value: remotePropertyDefinitions,
          enumerable: false
        },
        __remoteAttributeDefinitions: {
          value: remoteAttributeDefinitions,
          enumerable: false
        },
        __remoteEventDefinitions: {
          value: remoteEventDefinitions,
          enumerable: false
        },
        __attributeToPropertyMap: {
          value: attributeToPropertyMap,
          enumerable: false
        },
        __eventToPropertyMap: {
          value: eventToPropertyMap,
          enumerable: false
        }
      });
      return this;
    }
    // Just need to use these types so TS doesn’t lose track of them.
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor() {
      super();
      this.constructor.finalize();
      const propertyDescriptors = {};
      const initialPropertiesToSet = {};
      const prototype = Object.getPrototypeOf(this);
      const ThisClass = this.constructor;
      for (const [property, description] of ThisClass.remotePropertyDefinitions.entries()) {
        const aliasedName = description.name;
        if (prototype.hasOwnProperty(property)) {
          continue;
        }
        if (property === aliasedName) {
          initialPropertiesToSet[property] = description.default;
        }
        const propertyDescriptor = {
          configurable: true,
          enumerable: property === aliasedName,
          get: () => {
            return remoteProperties(this)?.[aliasedName];
          },
          set: (value) => {
            updateRemoteElementProperty(this, aliasedName, value);
          }
        };
        propertyDescriptors[property] = propertyDescriptor;
      }
      for (const [event, definition] of ThisClass.remoteEventDefinitions.entries()) {
        const propertyFromDefinition = definition.property ?? true;
        if (!propertyFromDefinition) continue;
        const property = propertyFromDefinition === true ? \`on\${event}\` : propertyFromDefinition;
        propertyDescriptors[property] = {
          configurable: true,
          enumerable: true,
          get: () => {
            return getRemoteEvents(this).properties.get(property) ?? null;
          },
          set: (value) => {
            const remoteEvents = getRemoteEvents(this);
            const currentListener = remoteEvents.properties.get(property);
            if (typeof value === "function") {
              let handler = function(...args) {
                return value.call(this, ...args);
              };
              remoteEvents.properties.set(property, handler);
              this.addEventListener(event, handler);
            } else {
              remoteEvents.properties.delete(property);
            }
            if (currentListener) {
              this.removeEventListener(event, currentListener);
            }
          }
        };
      }
      Object.defineProperties(this, propertyDescriptors);
      Object.assign(this, initialPropertiesToSet);
    }
    attributeChangedCallback(attribute, _oldValue, newValue) {
      if (attribute === "slot" && this.constructor.slottable) {
        updateRemoteElementAttribute(this, attribute, newValue ? String(newValue) : void 0);
        return;
      }
      const {
        remotePropertyDefinitions,
        remoteAttributeDefinitions,
        __attributeToPropertyMap: attributeToPropertyMap
      } = this.constructor;
      if (remoteAttributeDefinitions.has(attribute)) {
        updateRemoteElementAttribute(this, attribute, newValue);
        return;
      }
      const property = attributeToPropertyMap.get(attribute);
      const propertyDefinition = property == null ? property : remotePropertyDefinitions.get(property);
      if (propertyDefinition == null) return;
      this[property] = convertAttributeValueToProperty(newValue, propertyDefinition.type);
    }
    connectedCallback() {
      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {
        if (descriptor.bubbles) {
          this.addEventListener(event, noopBubblesEventListener);
        }
      }
    }
    disconnectedCallback() {
      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {
        if (descriptor.bubbles) {
          this.removeEventListener(event, noopBubblesEventListener);
        }
      }
    }
    addEventListener(type, listener, options) {
      const {
        remoteEventDefinitions,
        __eventToPropertyMap: eventToPropertyMap
      } = this.constructor;
      const listenerDefinition = remoteEventDefinitions.get(type);
      const property = eventToPropertyMap.get(type);
      if (listenerDefinition == null && property == null) {
        return super.addEventListener(type, listener, options);
      }
      const remoteEvents = getRemoteEvents(this);
      const remoteEvent = getRemoteEventRecord.call(this, type, {
        property,
        definition: listenerDefinition
      });
      const normalizedListener = typeof options === "object" && options?.once ? (...args) => {
        const result = typeof listener === "object" ? listener.handleEvent(...args) : listener.call(this, ...args);
        removeRemoteListener.call(this, type, listener, listenerRecord);
        return result;
      } : listener;
      const listenerRecord = [normalizedListener, remoteEvent];
      remoteEvent.listeners.add(listener);
      remoteEvents.listeners.set(listener, listenerRecord);
      super.addEventListener(type, normalizedListener, options);
      if (typeof options === "object" && options.signal) {
        options.signal.addEventListener("abort", () => {
          removeRemoteListener.call(this, type, listener, listenerRecord);
        }, {
          once: true
        });
      }
      if (listenerDefinition) {
        updateRemoteElementEventListener(this, type, remoteEvent.dispatch);
      } else {
        updateRemoteElementProperty(this, property, remoteEvent.dispatch);
      }
    }
    removeEventListener(type, listener, options) {
      const listenerRecord = REMOTE_EVENTS.get(this)?.listeners.get(listener);
      const normalizedListener = listenerRecord ? listenerRecord[0] : listener;
      super.removeEventListener(type, normalizedListener, options);
      if (listenerRecord == null) return;
      removeRemoteListener.call(this, type, listener, listenerRecord);
    }
    /**
     * Updates a single remote property on an element node. If the element is
     * connected to a remote root, this function will also make a \`mutate()\` call
     * to communicate the change to the host.
     */
    updateRemoteProperty(name, value) {
      updateRemoteElementProperty(this, name, value);
    }
    /**
     * Updates a single remote attribute on an element node. If the element is
     * connected to a remote root, this function will also make a \`mutate()\` call
     * to communicate the change to the host.
     */
    updateRemoteAttribute(name, value) {
      updateRemoteElementAttribute(this, name, value);
    }
    /**
     * Performs a method through \`RemoteConnection.call()\`, using the remote ID and
     * connection for the provided node.
     */
    callRemoteMethod(method, ...args) {
      return callRemoteElementMethod(this, method, ...args);
    }
  };
  __publicField(RemoteElement, "slottable", true);
  __publicField(RemoteElement, "__finalized", true);
  __publicField(RemoteElement, "__observedAttributes", []);
  __publicField(RemoteElement, "__attributeToPropertyMap", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__eventToPropertyMap", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remotePropertyDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remoteAttributeDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remoteEventDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remoteSlotDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  var REMOTE_EVENTS = /* @__PURE__ */ new WeakMap();
  function getRemoteEvents(element) {
    let events = REMOTE_EVENTS.get(element);
    if (events) return events;
    events = {
      events: /* @__PURE__ */ new Map(),
      properties: /* @__PURE__ */ new Map(),
      listeners: /* @__PURE__ */ new WeakMap()
    };
    REMOTE_EVENTS.set(element, events);
    return events;
  }
  function getRemoteEventRecord(type, {
    property,
    definition
  }) {
    const remoteEvents = getRemoteEvents(this);
    let remoteEvent = remoteEvents.events.get(type);
    if (remoteEvent == null) {
      remoteEvent = {
        name: type,
        property,
        definition,
        listeners: /* @__PURE__ */ new Set(),
        dispatch: (arg) => {
          const event = definition?.dispatchEvent?.call(this, arg) ?? new RemoteEvent(type, {
            detail: arg,
            bubbles: definition?.bubbles
          });
          this.dispatchEvent(event);
          return event.response;
        }
      };
      remoteEvents.events.set(type, remoteEvent);
    }
    return remoteEvent;
  }
  function removeRemoteListener(type, listener, listenerRecord) {
    const remoteEvents = getRemoteEvents(this);
    const remoteEvent = listenerRecord[1];
    remoteEvent.listeners.delete(listener);
    remoteEvents.listeners.delete(listener);
    if (remoteEvent.listeners.size > 0) return;
    remoteEvents.events.delete(type);
    if (remoteEvent.property) {
      if (remoteProperties(this)?.[remoteEvent.property] === remoteEvent.dispatch) {
        updateRemoteElementProperty(this, remoteEvent.property, void 0);
      }
    } else {
      if (remoteEventListeners(this)?.[type] === remoteEvent.dispatch) {
        updateRemoteElementEventListener(this, type, void 0);
      }
    }
  }
  function saveRemoteProperty(name, description, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap) {
    if (remotePropertyDefinitions.has(name)) {
      return remotePropertyDefinitions.get(name);
    }
    const looksLikeEventCallback = name[0] === "o" && name[1] === "n";
    const resolvedDescription = description ?? {};
    let {
      alias
    } = resolvedDescription;
    const {
      type = looksLikeEventCallback ? Function : String,
      attribute = type !== Function,
      event = looksLikeEventCallback,
      default: defaultValue = type === Boolean ? false : void 0
    } = resolvedDescription;
    if (alias == null) {
      const lowercaseProperty = name.toLowerCase();
      if (lowercaseProperty !== name) {
        alias = [lowercaseProperty];
      }
      if (looksLikeEventCallback) {
        alias ?? (alias = []);
        alias.unshift(\`_\${name}\`);
      }
    }
    let attributeName;
    if (attribute === true) {
      attributeName = camelToKebabCase(name);
    } else if (typeof attribute === "string") {
      attributeName = attribute;
    }
    if (attributeName) {
      if (Array.isArray(observedAttributes)) {
        observedAttributes.push(attributeName);
      } else {
        observedAttributes.add(attributeName);
      }
      attributeToPropertyMap.set(attributeName, name);
    }
    let eventName;
    if (event === true) {
      eventName = camelToKebabCase(looksLikeEventCallback ? name.slice(2) : name);
    } else if (typeof event === "string") {
      eventName = event;
    }
    if (eventName) {
      eventToPropertyMap.set(eventName, name);
    }
    const definition = {
      name,
      type,
      alias,
      event: eventName,
      attribute: attributeName,
      default: defaultValue
    };
    remotePropertyDefinitions.set(name, definition);
    if (alias) {
      for (const propertyAlias of alias) {
        remotePropertyDefinitions.set(propertyAlias, definition);
      }
    }
    return definition;
  }
  function convertAttributeValueToProperty(value, type) {
    if (value == null) return void 0;
    switch (type) {
      case Boolean:
        return value != null && value !== "false";
      case Object:
      case Array:
        try {
          return JSON.parse(value);
        } catch {
          return void 0;
        }
      case String:
        return String(value);
      case Number:
        return Number.parseFloat(value);
      case Function:
        return void 0;
      default: {
        return type.parse?.(value);
      }
    }
  }
  function camelToKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function noopBubblesEventListener() {
  }

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteMutationObserver.mjs
  var RemoteMutationObserver = class extends MutationObserver {
    constructor(connection) {
      super((records) => {
        const addedNodes = [];
        const remoteRecords = [];
        for (const record of records) {
          const targetId = remoteId(record.target);
          if (record.type === "childList") {
            const position = record.previousSibling ? indexOf(record.previousSibling, record.target.childNodes) + 1 : 0;
            record.removedNodes.forEach((node) => {
              disconnectRemoteNode(node);
              remoteRecords.push([MUTATION_TYPE_REMOVE_CHILD, targetId, position]);
            });
            record.addedNodes.forEach((node, index) => {
              if (addedNodes.some((addedNode) => {
                return addedNode === node || addedNode.contains(node);
              })) {
                return;
              }
              addedNodes.push(node);
              connectRemoteNode(node, connection);
              remoteRecords.push([MUTATION_TYPE_INSERT_CHILD, targetId, serializeRemoteNode(node), position + index]);
            });
          } else if (record.type === "characterData") {
            remoteRecords.push([MUTATION_TYPE_UPDATE_TEXT, targetId, record.target.textContent ?? ""]);
          } else if (record.type === "attributes" && record.attributeName != null && record.target instanceof Element && !record.target.tagName.includes("-")) {
            remoteRecords.push([MUTATION_TYPE_UPDATE_PROPERTY, targetId, record.attributeName, record.target.getAttribute(record.attributeName)]);
          }
        }
        connection.mutate(remoteRecords);
      });
      this.connection = connection;
    }
    /**
     * Starts watching changes to the element, and communicates changes to the
     * host environment. By default, this method will also communicate any initial
     * children of the element to the host environment.
     */
    observe(target, options) {
      REMOTE_IDS.set(target, ROOT_ID);
      if (options?.initial !== false && target.childNodes.length > 0) {
        const records = [];
        for (let i = 0; i < target.childNodes.length; i++) {
          const node = target.childNodes[i];
          connectRemoteNode(node, this.connection);
          records.push([MUTATION_TYPE_INSERT_CHILD, ROOT_ID, serializeRemoteNode(node), i]);
        }
        this.connection.mutate(records);
      }
      super.observe(target, {
        subtree: true,
        childList: true,
        attributes: true,
        characterData: true,
        ...options
      });
    }
  };
  function indexOf(node, list) {
    for (let i = 0; i < list.length; i++) {
      if (list[i] === node) return i;
    }
    return -1;
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/constants.mjs
  var MESSAGE_CALL = 1;
  var MESSAGE_CALL_RESULT = 2;
  var MESSAGE_FUNCTION_CALL = 3;
  var MESSAGE_FUNCTION_RESULT = 4;
  var MESSAGE_FUNCTION_RELEASE = 5;
  var SERIALIZE_METHOD = Symbol.for("quilt.threads.serialize");
  var TRANSFERABLE = Symbol.for("quilt.threads.transferable");

  // ../../node_modules/.pnpm/@quilted+events@2.1.3/node_modules/@quilted/events/build/esm/abort/NestedAbortController.mjs
  var NestedAbortController = class extends AbortController {
    constructor(...parents) {
      super();
      const abortedSignal = parents.find((signal) => signal.aborted);
      if (abortedSignal) {
        this.abort(abortedSignal.reason);
      } else {
        const abort = (event) => this.abort(event.target.reason);
        const options = {
          signal: this.signal
        };
        for (const signal of parents) {
          signal.addEventListener("abort", abort, options);
        }
      }
    }
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/errors.mjs
  var ThreadClosedError = class extends Error {
    constructor() {
      super("You attempted to call a function on a closed thread.");
    }
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/nanoid.mjs
  var a = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  function nanoid(e = 21) {
    let t = "", r = crypto.getRandomValues(new Uint8Array(e));
    for (let n = 0; n < e; n++) t += a[63 & r[n]];
    return t;
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/functions/ThreadFunctionsAutomatic.mjs
  var _functionsToId, _idsToFunction, _idsToProxy, _finalization, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn;
  var ThreadFunctionsAutomatic = class {
    constructor() {
      __privateAdd(this, _ThreadFunctionsAutomatic_instances);
      __privateAdd(this, _functionsToId, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      __privateAdd(this, _idsToFunction, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      __privateAdd(this, _idsToProxy, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      __privateAdd(this, _finalization, /* @__PURE__ */ (() => /* @__PURE__ */ new WeakMap())());
    }
    get(id2) {
      return __privateGet(this, _idsToFunction).get(id2);
    }
    release(id2) {
      const func = __privateGet(this, _idsToFunction).get(id2);
      if (func) {
        __privateGet(this, _idsToFunction).delete(id2);
        __privateGet(this, _functionsToId).delete(func);
      }
      return Boolean(func);
    }
    serialize(func) {
      let id2 = __privateGet(this, _functionsToId).get(func);
      if (id2 == null) {
        id2 = nanoid();
        __privateGet(this, _functionsToId).set(func, id2);
        __privateGet(this, _idsToFunction).set(id2, func);
      }
      return id2;
    }
    deserialize(id2, thread) {
      let proxy = __privateGet(this, _idsToProxy).get(id2)?.deref();
      if (proxy) return proxy;
      proxy = (...args) => {
        if (!__privateGet(this, _idsToProxy).has(id2)) {
          throw new Error("You attempted to call a function that was already revoked.");
        }
        return thread.call((callID, args2, transferable) => {
          thread.messages.send([MESSAGE_FUNCTION_CALL, callID, id2, args2], transferable);
        }, args);
      };
      __privateMethod(this, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn).call(this, thread)?.register(proxy, id2);
      __privateGet(this, _idsToProxy).set(id2, new WeakRef(proxy));
      return proxy;
    }
  };
  _functionsToId = new WeakMap();
  _idsToFunction = new WeakMap();
  _idsToProxy = new WeakMap();
  _finalization = new WeakMap();
  _ThreadFunctionsAutomatic_instances = new WeakSet();
  finalizationRegistry_fn = function(thread) {
    let finalization = __privateGet(this, _finalization).get(thread);
    if (typeof FinalizationRegistry === "undefined") {
      return void 0;
    }
    if (!finalization) {
      finalization = new FinalizationRegistry((id2) => {
        thread.messages.send([MESSAGE_FUNCTION_RELEASE, id2]);
      });
      __privateGet(this, _finalization).set(thread, finalization);
    }
    return finalization;
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/shared.mjs
  function isIterator(value) {
    return value != null && (Symbol.asyncIterator in value || Symbol.iterator in value) && typeof value.next === "function";
  }
  function isBasicObject(value) {
    if (value == null || typeof value !== "object") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype == null || prototype === Object.prototype;
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/ThreadSerializationStructuredClone.mjs
  var FUNCTION = "_@f";
  var ASYNC_ITERATOR = "_@i";
  var _customSerializer, _customDeserializer, _ThreadSerializationStructuredClone_instances, serializeInternal_fn, deserializeInternal_fn;
  var ThreadSerializationStructuredClone = class {
    constructor(options) {
      __privateAdd(this, _ThreadSerializationStructuredClone_instances);
      __privateAdd(this, _customSerializer);
      __privateAdd(this, _customDeserializer);
      __privateSet(this, _customSerializer, options?.serialize);
      __privateSet(this, _customDeserializer, options?.deserialize);
    }
    /**
     * Serializes a value into a structured cloning-compatible format that can be transferred between threads.
     */
    serialize(value, thread, transferable) {
      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value, thread, transferable);
    }
    /**
     * Deserializes a structured cloning-compatible value from another thread.
     */
    deserialize(value, thread) {
      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value, thread);
    }
  };
  _customSerializer = new WeakMap();
  _customDeserializer = new WeakMap();
  _ThreadSerializationStructuredClone_instances = new WeakSet();
  serializeInternal_fn = function(value, thread, transferable, seen = /* @__PURE__ */ new Map(), isApplyingDefault = false) {
    if (value == null) return value;
    if (seen.has(value)) return seen.get(value);
    seen.set(value, void 0);
    if (typeof value === "object") {
      if (__privateGet(this, _customSerializer) && !isApplyingDefault) {
        const customValue = __privateGet(this, _customSerializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen, true), thread, transferable);
        if (customValue !== void 0) {
          seen.set(value, customValue);
          return customValue;
        }
      }
      if (value[TRANSFERABLE]) {
        transferable?.push(value);
        seen.set(value, value);
        return value;
      }
      const serializeValue = (value2) => {
        return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen);
      };
      if (typeof value[SERIALIZE_METHOD] === "function") {
        const result = value[SERIALIZE_METHOD]({
          serialize: serializeValue
        });
        seen.set(value, result);
        return result;
      }
      if (Array.isArray(value)) {
        const result = value.map((item) => serializeValue(item));
        seen.set(value, result);
        return result;
      }
      if (value instanceof Map) {
        const entries = [...value.entries()].map(([key, value2]) => {
          return [serializeValue(key), serializeValue(value2)];
        });
        const result = new Map(entries);
        seen.set(value, result);
        return result;
      }
      if (value instanceof Set) {
        const entries = [...value].map((entry) => serializeValue(entry));
        const result = new Set(entries);
        seen.set(value, result);
        return result;
      }
      const valueIsIterator = isIterator(value);
      if (isBasicObject(value) || valueIsIterator) {
        const result = {};
        for (const key of Object.keys(value)) {
          result[key] = serializeValue(value[key]);
        }
        if (valueIsIterator) {
          result.next ?? (result.next = serializeValue(value.next.bind(value)));
          result.return ?? (result.return = serializeValue(value.return.bind(value)));
          result.throw ?? (result.throw = serializeValue(value.throw.bind(value)));
          result[ASYNC_ITERATOR] = true;
        }
        seen.set(value, result);
        return result;
      }
    }
    if (typeof value === "function") {
      const serialized = thread.functions.serialize(value, thread, transferable);
      const result = {
        [FUNCTION]: serialized
      };
      seen.set(value, result);
      return result;
    }
    seen.set(value, value);
    return value;
  };
  deserializeInternal_fn = function(value, thread, isApplyingDefault = false) {
    if (value == null) return value;
    if (typeof value === "object") {
      if (__privateGet(this, _customDeserializer) && !isApplyingDefault) {
        const customValue = __privateGet(this, _customDeserializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread, true), thread);
        if (customValue !== void 0) {
          return customValue;
        }
      }
      if (value == null) {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread));
      }
      if (value instanceof Map) {
        return new Map([...value].map(([key, value2]) => [__privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, key, thread), __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread)]));
      }
      if (value instanceof Set) {
        return new Set([...value].map((entry) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, entry, thread)));
      }
      if (FUNCTION in value) {
        const func = thread.functions.deserialize(value[FUNCTION], thread);
        return func;
      }
      if (!isBasicObject(value)) {
        return value;
      }
      const result = {};
      for (const key of Object.keys(value)) {
        if (key === ASYNC_ITERATOR) {
          result[Symbol.asyncIterator] = () => result;
        } else {
          result[key] = __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value[key], thread);
        }
      }
      return result;
    }
    return value;
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/Thread.mjs
  var _abort, _idsToResolver, _Thread_instances, callLocal_fn, handlerForCall_fn, resolveCall_fn, waitForResult_fn;
  var Thread = class {
    constructor(messages, {
      imports,
      exports,
      functions = new ThreadFunctionsAutomatic(),
      serialization = new ThreadSerializationStructuredClone(),
      signal
    } = {}) {
      __privateAdd(this, _Thread_instances);
      __privateAdd(this, _abort);
      __privateAdd(this, _idsToResolver, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      this.messages = messages;
      __privateSet(this, _abort, signal ? new NestedAbortController(signal) : new AbortController());
      this.exports = exports ?? {};
      this.imports = createThreadImports(__privateMethod(this, _Thread_instances, handlerForCall_fn).bind(this), imports);
      this.functions = functions;
      this.serialization = serialization;
      this.functions.start?.(this);
      this.serialization.start?.(this);
      this.signal.addEventListener("abort", () => {
        for (const id2 of __privateGet(this, _idsToResolver).keys()) {
          __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, id2, void 0, new ThreadClosedError());
        }
        __privateGet(this, _idsToResolver).clear();
      }, {
        once: true
      });
      messages.listen(async (rawData) => {
        const isThreadMessageData = Array.isArray(rawData) && typeof rawData[0] === "number";
        if (!isThreadMessageData) {
          return;
        }
        const data = rawData;
        switch (data[0]) {
          case MESSAGE_CALL: {
            const [, id2, property, args] = data;
            const func = this.exports[property] ?? (() => {
              throw new Error(\`No '\${property}' method is exported from this thread\`);
            });
            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {
              this.messages.send([MESSAGE_CALL_RESULT, id2, value, error], transferable);
            });
            break;
          }
          case MESSAGE_FUNCTION_CALL: {
            const [, callID, funcID, args] = data;
            const func = this.functions.get(funcID, this) ?? missingThreadFunction;
            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {
              this.messages.send([MESSAGE_FUNCTION_RESULT, callID, value, error], transferable);
            });
            break;
          }
          case MESSAGE_CALL_RESULT:
          case MESSAGE_FUNCTION_RESULT: {
            __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, ...data.slice(1));
            break;
          }
          case MESSAGE_FUNCTION_RELEASE: {
            const id2 = data[1];
            this.functions.release(id2, this);
            break;
          }
        }
      }, {
        signal: this.signal
      });
    }
    /**
     * An object that exposes the methods that can be called on the paired thread.
     * This object will automatically encode and decode arguments and return values
     * as necessary.
     */
    /**
     * An object that exposes the methods that can be called on this thread by the
     * paired thread. To set these methods, pass the \`exports\` option when creating
     * a new \`Thread\`.
     */
    /**
     * An object that provides the message-passing interface that allows communication
     * to flow between environments.
     */
    /**
     * An object that manages how functions are proxied between threads.
     */
    /**
     * An object that manages how values are serialized and deserialized between threads.
     */
    /**
     * An \`AbortSignal\` that indicates whether the communication channel is still open.
     */
    get signal() {
      return __privateGet(this, _abort).signal;
    }
    /**
     * A boolean indicating whether the communication channel is still open.
     */
    get closed() {
      return __privateGet(this, _abort).signal.aborted;
    }
    /**
     * Closes the communication channel between the two threads. This will prevent
     * any further communication between the threads, and will clean up any memory
     * associated with in-progress communication. It will also reject any inflight
     * function calls between threads with a \`ThreadClosedError\`.
     */
    close() {
      __privateGet(this, _abort).abort();
    }
    /**
     * Requests that the thread provide the context needed to make a function
     * call between threads. You provide this method a function to call and the
     * unserialized arguments you wish to call it with, and the thread will call
     * the function you provided with a serialized call ID, the serialized arguments,
     * and any transferable objects that need to be passed between threads.
     */
    call(func, args) {
      if (this.closed) {
        return Promise.reject(new ThreadClosedError());
      }
      const transferable = [];
      const serialized = this.serialization.serialize(args, this, transferable);
      const id2 = nanoid();
      const done = __privateMethod(this, _Thread_instances, waitForResult_fn).call(this, id2);
      func(id2, serialized, transferable);
      return done;
    }
  };
  _abort = new WeakMap();
  _idsToResolver = new WeakMap();
  _Thread_instances = new WeakSet();
  callLocal_fn = async function(func, args, withResult) {
    try {
      const result = this.functions.call ? await this.functions.call(func, args, this) : await func(...this.serialization.deserialize(args, this));
      const transferable = [];
      const serialized = this.serialization.serialize(result, this, transferable);
      withResult(serialized, void 0, transferable);
    } catch (error) {
      withResult(void 0, this.serialization.serialize(error, this));
    }
  };
  handlerForCall_fn = function(property) {
    return (...args) => {
      try {
        if (typeof property !== "string" && typeof property !== "number") {
          throw new Error(\`Can’t call a symbol method on a thread: \${property.toString()}\`);
        }
        return this.call((id2, serializedArgs, transferable) => {
          this.messages.send([MESSAGE_CALL, id2, property, serializedArgs], transferable);
        }, args);
      } catch (error) {
        return Promise.reject(error);
      }
    };
  };
  resolveCall_fn = function(...args) {
    const callID = args[0];
    const resolver = __privateGet(this, _idsToResolver).get(callID);
    if (resolver) {
      resolver(...args);
      __privateGet(this, _idsToResolver).delete(callID);
    }
  };
  waitForResult_fn = function(id2) {
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _idsToResolver).set(id2, (_, value, error) => {
        if (error == null) {
          resolve(this.serialization.deserialize(value, this));
        } else {
          reject(this.serialization.deserialize(error, this));
        }
      });
    });
    Object.defineProperty(promise, Symbol.asyncIterator, {
      async *value() {
        const result = await promise;
        Object.defineProperty(result, Symbol.asyncIterator, {
          value: () => result
        });
        yield* result;
      }
    });
    return promise;
  };
  function createThreadImports(handlerForImport, imported) {
    let call;
    if (imported == null) {
      if (typeof Proxy !== "function") {
        throw new Error(\`You must pass an array of callable methods in environments without Proxies.\`);
      }
      const cache = /* @__PURE__ */ new Map();
      call = new Proxy({}, {
        get(_target, property) {
          if (cache.has(property)) {
            return cache.get(property);
          }
          const handler = handlerForImport(property);
          cache.set(property, handler);
          return handler;
        }
      });
    } else {
      call = {};
      for (const method of imported) {
        Object.defineProperty(call, method, {
          value: handlerForImport(method),
          writable: false,
          configurable: true,
          enumerable: true
        });
      }
    }
    return call;
  }
  function missingThreadFunction() {
    throw new Error(\`You attempted to call a function that is not stored. It may have already been released.\`);
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/shared.mjs
  var CHECK_MESSAGE = "quilt.threads.ping";
  var RESPONSE_MESSAGE = "quilt.threads.pong";

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/ThreadNestedWindow.mjs
  function nestedWindowToThreadTarget(parent, {
    targetOrigin = "*"
  } = {}) {
    const ready = () => {
      const respond = () => parent.postMessage(RESPONSE_MESSAGE, targetOrigin);
      self.addEventListener("message", ({
        data,
        source
      }) => {
        if (source !== parent) return;
        if (data === CHECK_MESSAGE) respond();
      });
      respond();
    };
    if (document.readyState === "complete") {
      ready();
    } else {
      document.addEventListener("readystatechange", () => {
        if (document.readyState === "complete") {
          ready();
        }
      });
    }
    return {
      send(message, transfer) {
        return parent.postMessage(message, targetOrigin, transfer);
      },
      listen(listen, {
        signal
      }) {
        self.addEventListener("message", (event) => {
          if (event.data === CHECK_MESSAGE) return;
          listen(event.data);
        }, {
          signal
        });
      }
    };
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/ThreadNestedIframe.mjs
  var ThreadNestedIframe = class extends Thread {
    constructor({
      parent = globalThis.parent,
      targetOrigin = "*",
      ...options
    } = {}) {
      if (typeof self === "undefined" || parent == null) {
        throw new Error("You are not inside an iframe, because there is no parent window.");
      }
      super(nestedWindowToThreadTarget(parent, {
        targetOrigin
      }), options);
      this.parent = parent;
    }
  };

  // scripts/iframe-entry.js
  new ThreadNestedIframe({
    exports: {
      async render(options, receiver, hostApi) {
        if (options.remoteElements) {
          options.remoteElements.forEach((def) => {
            if (customElements.get(def.tagName)) return;
            const remoteElement = class extends RemoteElement {
              static get remoteAttributes() {
                return def.remoteAttributes || [];
              }
              static get remoteEvents() {
                return def.remoteEvents || [];
              }
            };
            Object.defineProperty(remoteElement, "name", {
              value: \`Remote\${def.tagName.replace(/(^w|-w)/g, (c) => c.replace("-", "").toUpperCase())}\`
            });
            customElements.define(def.tagName, remoteElement);
          });
        }
        const root = document.querySelector("#root");
        const observer = new RemoteMutationObserver(receiver);
        observer.observe(root);
        const { code } = options;
        if (code && root) {
          try {
            const scriptFunction = new Function("root", "console", code);
            scriptFunction(root, console);
          } catch (e) {
            console.error("Error executing remote script:", e);
          }
        }
      }
    }
  });
})();

  <\/script>
</body>
</html>`,de=1,ue=2,pe=3,me=4,fe=5,he=Symbol.for("quilt.threads.serialize"),He=Symbol.for("quilt.threads.transferable");class qe extends AbortController{constructor(...e){super();const t=e.find(r=>r.aborted);if(t)this.abort(t.reason);else{const r=o=>this.abort(o.target.reason),i={signal:this.signal};for(const o of e)o.addEventListener("abort",r,i)}}}class _e extends Error{constructor(){super("You attempted to call a function on a closed thread.")}}let Be="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";function Ee(n=21){let e="",t=crypto.getRandomValues(new Uint8Array(n));for(let r=0;r<n;r++)e+=Be[63&t[r]];return e}class $e{constructor(){w(this,W);w(this,C,new Map);w(this,A,new Map);w(this,D,new Map);w(this,F,new WeakMap)}get(e){return v(this,A).get(e)}release(e){const t=v(this,A).get(e);return t&&(v(this,A).delete(e),v(this,C).delete(t)),!!t}serialize(e){let t=v(this,C).get(e);return t==null&&(t=Ee(),v(this,C).set(e,t),v(this,A).set(t,e)),t}deserialize(e,t){var i,o;let r=(i=v(this,D).get(e))==null?void 0:i.deref();return r||(r=(...a)=>{if(!v(this,D).has(e))throw new Error("You attempted to call a function that was already revoked.");return t.call((p,d,h)=>{t.messages.send([pe,p,e,d],h)},a)},(o=y(this,W,Me).call(this,t))==null||o.register(r,e),v(this,D).set(e,new WeakRef(r)),r)}}C=new WeakMap,A=new WeakMap,D=new WeakMap,F=new WeakMap,W=new WeakSet,Me=function(e){let t=v(this,F).get(e);if(!(typeof FinalizationRegistry>"u"))return t||(t=new FinalizationRegistry(r=>{e.messages.send([fe,r])}),v(this,F).set(e,t)),t};function Ke(n){return n!=null&&(Symbol.asyncIterator in n||Symbol.iterator in n)&&typeof n.next=="function"}function be(n){if(n==null||typeof n!="object")return!1;const e=Object.getPrototypeOf(n);return e==null||e===Object.prototype}const X="_@f",ve="_@i";class Ze{constructor(e){w(this,T);w(this,z);w(this,L);H(this,z,e==null?void 0:e.serialize),H(this,L,e==null?void 0:e.deserialize)}serialize(e,t,r){return y(this,T,q).call(this,e,t,r)}deserialize(e,t){return y(this,T,N).call(this,e,t)}}z=new WeakMap,L=new WeakMap,T=new WeakSet,q=function(e,t,r,i=new Map,o=!1){if(e==null)return e;if(i.has(e))return i.get(e);if(i.set(e,void 0),typeof e=="object"){if(v(this,z)&&!o){const d=v(this,z).call(this,e,h=>y(this,T,q).call(this,h,t,r,i,!0),t,r);if(d!==void 0)return i.set(e,d),d}if(e[He])return r==null||r.push(e),i.set(e,e),e;const a=d=>y(this,T,q).call(this,d,t,r,i);if(typeof e[he]=="function"){const d=e[he]({serialize:a});return i.set(e,d),d}if(Array.isArray(e)){const d=e.map(h=>a(h));return i.set(e,d),d}if(e instanceof Map){const d=[...e.entries()].map(([s,c])=>[a(s),a(c)]),h=new Map(d);return i.set(e,h),h}if(e instanceof Set){const d=[...e].map(s=>a(s)),h=new Set(d);return i.set(e,h),h}const p=Ke(e);if(be(e)||p){const d={};for(const h of Object.keys(e))d[h]=a(e[h]);return p&&(d.next??(d.next=a(e.next.bind(e))),d.return??(d.return=a(e.return.bind(e))),d.throw??(d.throw=a(e.throw.bind(e))),d[ve]=!0),i.set(e,d),d}}if(typeof e=="function"){const a=t.functions.serialize(e,t,r),p={[X]:a};return i.set(e,p),p}return i.set(e,e),e},N=function(e,t,r=!1){if(e==null)return e;if(typeof e=="object"){if(v(this,L)&&!r){const o=v(this,L).call(this,e,a=>y(this,T,N).call(this,a,t,!0),t);if(o!==void 0)return o}if(e==null)return e;if(Array.isArray(e))return e.map(o=>y(this,T,N).call(this,o,t));if(e instanceof Map)return new Map([...e].map(([o,a])=>[y(this,T,N).call(this,o,t),y(this,T,N).call(this,a,t)]));if(e instanceof Set)return new Set([...e].map(o=>y(this,T,N).call(this,o,t)));if(X in e)return t.functions.deserialize(e[X],t);if(!be(e))return e;const i={};for(const o of Object.keys(e))o===ve?i[Symbol.asyncIterator]=()=>i:i[o]=y(this,T,N).call(this,e[o],t);return i}return e};class Je{constructor(e,{imports:t,exports:r,functions:i=new $e,serialization:o=new Ze,signal:a}={}){w(this,g);w(this,I);w(this,M,new Map);var p,d,h,s;this.messages=e,H(this,I,a?new qe(a):new AbortController),this.exports=r??{},this.imports=Xe(y(this,g,Ne).bind(this),t),this.functions=i,this.serialization=o,(d=(p=this.functions).start)==null||d.call(p,this),(s=(h=this.serialization).start)==null||s.call(h,this),this.signal.addEventListener("abort",()=>{for(const c of v(this,M).keys())y(this,g,re).call(this,c,void 0,new _e);v(this,M).clear()},{once:!0}),e.listen(async c=>{if(!(Array.isArray(c)&&typeof c[0]=="number"))return;const u=c;switch(u[0]){case de:{const[,f,b,P]=u,R=this.exports[b]??(()=>{throw new Error(`No '${b}' method is exported from this thread`)});await y(this,g,te).call(this,R,P,(S,U,x)=>{this.messages.send([ue,f,S,U],x)});break}case pe:{const[,f,b,P]=u,R=this.functions.get(b,this)??Qe;await y(this,g,te).call(this,R,P,(S,U,x)=>{this.messages.send([me,f,S,U],x)});break}case ue:case me:{y(this,g,re).call(this,...u.slice(1));break}case fe:{const f=u[1];this.functions.release(f,this);break}}},{signal:this.signal})}get signal(){return v(this,I).signal}get closed(){return v(this,I).signal.aborted}close(){v(this,I).abort()}call(e,t){if(this.closed)return Promise.reject(new _e);const r=[],i=this.serialization.serialize(t,this,r),o=Ee(),a=y(this,g,Ae).call(this,o);return e(o,i,r),a}}I=new WeakMap,M=new WeakMap,g=new WeakSet,te=async function(e,t,r){try{const i=this.functions.call?await this.functions.call(e,t,this):await e(...this.serialization.deserialize(t,this)),o=[],a=this.serialization.serialize(i,this,o);r(a,void 0,o)}catch(i){r(void 0,this.serialization.serialize(i,this))}},Ne=function(e){return(...t)=>{try{if(typeof e!="string"&&typeof e!="number")throw new Error(`Can’t call a symbol method on a thread: ${e.toString()}`);return this.call((r,i,o)=>{this.messages.send([de,r,e,i],o)},t)}catch(r){return Promise.reject(r)}}},re=function(...e){const t=e[0],r=v(this,M).get(t);r&&(r(...e),v(this,M).delete(t))},Ae=function(e){const t=new Promise((r,i)=>{v(this,M).set(e,(o,a,p)=>{p==null?r(this.serialization.deserialize(a,this)):i(this.serialization.deserialize(p,this))})});return Object.defineProperty(t,Symbol.asyncIterator,{async*value(){const r=await t;Object.defineProperty(r,Symbol.asyncIterator,{value:()=>r}),yield*r}}),t};function Xe(n,e){let t;if(e==null){if(typeof Proxy!="function")throw new Error("You must pass an array of callable methods in environments without Proxies.");const r=new Map;t=new Proxy({},{get(i,o){if(r.has(o))return r.get(o);const a=n(o);return r.set(o,a),a}})}else{t={};for(const r of e)Object.defineProperty(t,r,{value:n(r),writable:!1,configurable:!0,enumerable:!0})}return t}function Qe(){throw new Error("You attempted to call a function that is not stored. It may have already been released.")}const et="quilt.threads.ping",ye="quilt.threads.pong";function tt(n,{targetOrigin:e="*"}={}){let t=!1;const r=function(a,p){n.postMessage(a,e,p)},i=new Promise(o=>{const a=new AbortController;globalThis.window.addEventListener("message",p=>{p.source===n&&p.data===ye&&(t=!0,a.abort(),o())},{signal:a.signal}),a.signal.addEventListener("abort",()=>o(),{once:!0}),r(et)});return{send(o,a){return t?r(o,a):i.then(()=>{if(t)return r(o,a)})},listen(o,{signal:a}){self.addEventListener("message",p=>{p.source===n&&p.data!==ye&&o(p.data)},{signal:a})}}}class rt extends Je{constructor(e,{targetOrigin:t="*",...r}={}){super(tt(e.contentWindow,{targetOrigin:t}),r),this.iframe=e}}const Te=_.forwardRef(({content:n,children:e,...t},r)=>m.jsx("span",{ref:r,...t,children:n||e}));Te.displayName="UIText";const ge=_.forwardRef(({label:n,onPress:e,onClick:t,children:r,...i},o)=>{const a=p=>{e&&e(),t&&t(p)};return m.jsx("button",{ref:o,onClick:a,style:{padding:"8px 16px",backgroundColor:"#007bff",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},...i,children:n||r})});ge.displayName="UIButton";const Re=_.forwardRef(({direction:n="vertical",spacing:e="8",align:t="stretch",justify:r="flex-start",children:i,...o},a)=>m.jsx("div",{ref:a,style:{display:"flex",flexDirection:n==="horizontal"?"row":"column",gap:`${e}px`,alignItems:t,justifyContent:r},...o,children:i}));Re.displayName="UIStack";const we=_.forwardRef(({src:n,alt:e,width:t,height:r,children:i,...o},a)=>m.jsx("img",{ref:a,src:n,alt:e,width:t,height:r,style:{maxWidth:"100%",height:"auto",borderRadius:"8px",boxShadow:"0 2px 8px rgba(0, 0, 0, 0.1)"},...o}));we.displayName="UIImage";const Q={name:"basic",elements:[{tagName:"ui-text",component:Te,propMapping:{content:"content"},eventMapping:{}},{tagName:"ui-button",component:ge,propMapping:{label:"label"},eventMapping:{press:"onPress"}},{tagName:"ui-stack",component:Re,propMapping:{direction:"direction",spacing:"spacing",align:"align",justify:"justify"},eventMapping:{}},{tagName:"ui-image",component:we,propMapping:{src:"src",alt:"alt",width:"width",height:"height"},eventMapping:{}}]},nt=({receiver:n})=>{const e=_.useRef(null);return _.useEffect(()=>{if(e.current)return n.connect(e.current),()=>{n.disconnect()}},[n]),m.jsx("div",{ref:e,"data-testid":"standard-dom-renderer-container"})},Pe=({resource:n,library:e,remoteElements:t=[],onUiAction:r})=>{const i=_.useRef(null),o=_.useRef(null),a=_.useMemo(()=>(n.mimeType||"").includes("flavor=react")?"react":"webcomponents",[n.mimeType]),p=`${e==null?void 0:e.name}-${a}`,{receiver:d,components:h}=_.useMemo(()=>{switch(a){case"react":{const c=new Le,l=e||Q,u=new Map;return l&&l.elements.forEach(f=>{const b=Ye(f.component);u.set(f.tagName,b)}),{receiver:c,components:u}}case"webcomponents":default:return{receiver:new Ue,components:null}}},[n,e,t]);_.useEffect(()=>{function c(l){var u;if(i.current&&l.source===i.current.contentWindow){const f=l.data;if(!f)return;(u=r==null?void 0:r(f))==null||u.catch(b=>{console.error("Error handling UI action result in RemoteDomResource:",b)})}}return window.addEventListener("message",c),()=>window.removeEventListener("message",c)},[r]),_.useEffect(()=>{const c=o.current;return o.current=null,()=>{c==null||c.close()}},[p]);const s=()=>{const c=i.current;if(!c||o.current)return;const l=new rt(c);if(o.current=l,n.content&&typeof n.content=="string"&&(d!=null&&d.connection)){const u={code:n.content,remoteElements:t,useReactRenderer:a==="react",componentLibrary:e==null?void 0:e.name};l.imports.render(u,d.connection).catch(f=>console.error("Error calling remote render:",f))}};return m.jsxs(m.Fragment,{children:[m.jsx("iframe",{ref:i,srcDoc:We,sandbox:"allow-scripts",style:{display:"none"},title:"Remote DOM Sandbox",onLoad:s},p),a==="react"&&h?m.jsx(Ve,{receiver:d,components:h}):m.jsx(nt,{receiver:d})]})};function ot(n){var e;if(n.contentType)return n.contentType;if(n.mimeType==="text/html")return"rawHtml";if(n.mimeType==="text/uri-list")return"externalUrl";if((e=n.mimeType)!=null&&e.startsWith("application/vnd.mcp-ui.remote-dom"))return"remoteDom"}const it=n=>{const{resource:e,onUiAction:t,style:r,iframeProps:i,supportedContentTypes:o,library:a}=n,p=ot(e);if(o&&p&&!o.includes(p))return m.jsxs("p",{className:"text-red-500",children:["Unsupported content type: ",p,"."]});switch(p){case"rawHtml":case"externalUrl":return m.jsx(B,{resource:e,onUiAction:t,style:r,iframeProps:i});case"remoteDom":return m.jsx(Pe,{resource:e,onUiAction:t,library:a||Q});default:return m.jsx("p",{className:"text-red-500",children:"Unsupported resource type."})}},st={tagName:"ui-card"},at={tagName:"ui-button",remoteAttributes:["label"],remoteEvents:["click","press"]},lt={tagName:"ui-text",remoteAttributes:["content"]},ct={tagName:"ui-stack",remoteAttributes:["direction","spacing","align","justify"]},dt={tagName:"ui-image",remoteAttributes:["src","alt","width","height"]};E.HtmlResource=B,E.RemoteDomResource=Pe,E.ResourceRenderer=it,E.basicComponentLibrary=Q,E.remoteButtonDefinition=at,E.remoteCardDefinition=st,E.remoteImageDefinition=dt,E.remoteStackDefinition=ct,E.remoteTextDefinition=lt,Object.defineProperty(E,Symbol.toStringTag,{value:"Module"})});
