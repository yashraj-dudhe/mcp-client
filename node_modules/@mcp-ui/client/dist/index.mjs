var De = Object.defineProperty;
var oe = (r) => {
  throw TypeError(r);
};
var ze = (r, e, t) => e in r ? De(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var M = (r, e, t) => ze(r, typeof e != "symbol" ? e + "" : e, t), $ = (r, e, t) => e.has(r) || oe("Cannot " + t);
var _ = (r, e, t) => ($(r, e, "read from private field"), t ? t.call(r) : e.get(r)), T = (r, e, t) => e.has(r) ? oe("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), G = (r, e, t, n) => ($(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), b = (r, e, t) => ($(r, e, "access private method"), t);
import { jsx as E, Fragment as B, jsxs as ee } from "react/jsx-runtime";
import Y, { useRef as k, useImperativeHandle as Le, useMemo as Z, useEffect as U, useState as Ue, useDebugValue as xe, memo as ke } from "react";
function je(r) {
  const e = typeof r.uri == "string" && r.uri.startsWith("ui-app://"), t = e ? "text/uri-list" : r.mimeType;
  if (t !== "text/html" && t !== "text/uri-list")
    return {
      error: "Resource must be of type text/html (for HTML content) or text/uri-list (for URL content)."
    };
  if (t === "text/uri-list") {
    let n = "";
    if (typeof r.text == "string" && r.text.trim() !== "")
      n = r.text;
    else if (typeof r.blob == "string")
      try {
        n = new TextDecoder().decode(
          Uint8Array.from(atob(r.blob), (o) => o.charCodeAt(0))
        );
      } catch (o) {
        return console.error("Error decoding base64 blob for URL content:", o), {
          error: "Error decoding URL from blob."
        };
      }
    else
      return {
        error: "URL resource expects a non-empty text or blob field containing the URL."
      };
    if (n.trim() === "")
      return {
        error: "URL content is empty."
      };
    const i = n.split(`
`).map((o) => o.trim()).filter((o) => o && !o.startsWith("#"));
    return i.length === 0 ? {
      error: "No valid URLs found in uri-list content."
    } : (i.length > 1 && console.warn(
      `Multiple URLs found in uri-list content. Using the first URL: "${i[0]}". Other URLs ignored:`,
      i.slice(1)
    ), e && console.warn(
      `Detected legacy ui-app:// URI: "${r.uri}". Update server to use ui:// with mimeType: 'text/uri-list' for future compatibility.`
    ), {
      iframeSrc: i[0],
      iframeRenderMode: "src"
    });
  } else if (t === "text/html") {
    if (typeof r.text == "string")
      return {
        htmlString: r.text,
        iframeRenderMode: "srcDoc"
      };
    if (typeof r.blob == "string")
      try {
        return {
          htmlString: new TextDecoder().decode(
            Uint8Array.from(atob(r.blob), (i) => i.charCodeAt(0))
          ),
          iframeRenderMode: "srcDoc"
        };
      } catch (n) {
        return console.error("Error decoding base64 blob for HTML content:", n), {
          error: "Error decoding HTML content from blob."
        };
      }
    else
      return {
        error: "HTML resource requires text or blob content."
      };
  } else
    return {
      error: "Unsupported mimeType. Expected text/html or text/uri-list."
    };
}
const he = Y.forwardRef(
  ({ resource: r, onUiAction: e, style: t, iframeProps: n }, i) => {
    const o = k(null);
    Le(i, () => o.current);
    const { error: a, iframeSrc: p, iframeRenderMode: d, htmlString: f } = Z(
      () => je(r),
      [r]
    );
    return U(() => {
      function s(c) {
        var l;
        if (o.current && c.source === o.current.contentWindow) {
          const u = c.data;
          if (!u)
            return;
          (l = e == null ? void 0 : e(u)) == null || l.catch((m) => {
            console.error(
              "Error handling UI action result in RenderHtmlResource:",
              m
            );
          });
        }
      }
      return window.addEventListener("message", s), () => window.removeEventListener("message", s);
    }, [e]), a ? /* @__PURE__ */ E("p", { className: "text-red-500", children: a }) : d === "srcDoc" ? f == null ? a ? null : /* @__PURE__ */ E("p", { className: "text-orange-500", children: "No HTML content to display." }) : /* @__PURE__ */ E(
      "iframe",
      {
        srcDoc: f,
        sandbox: "allow-scripts",
        style: { width: "100%", minHeight: 200, ...t },
        title: "MCP HTML Resource (Embedded Content)",
        ...n,
        ref: o
      }
    ) : d === "src" ? p == null ? a ? null : /* @__PURE__ */ E("p", { className: "text-orange-500", children: "No URL provided for HTML resource." }) : /* @__PURE__ */ E(
      "iframe",
      {
        src: p,
        sandbox: "allow-scripts allow-same-origin",
        style: { width: "100%", minHeight: 200, ...t },
        title: "MCP HTML Resource (URL)",
        ...n,
        ref: o
      }
    ) : /* @__PURE__ */ E("p", { className: "text-gray-500", children: "Initializing HTML resource display..." });
  }
);
he.displayName = "HtmlResource";
const _e = 1, Ee = 3, be = 8, Fe = 9, Ye = 0, Ge = 1, Ve = 2, We = 3, j = 1, te = 2, re = 3, x = "~";
function ve({
  call: r,
  insertChild: e,
  removeChild: t,
  updateText: n,
  updateProperty: i
}) {
  const o = {
    [Ye]: e,
    [Ge]: t,
    [Ve]: n,
    [We]: i
  };
  return {
    call: r,
    mutate(a) {
      for (const [p, ...d] of a)
        o[p](...d);
    }
  };
}
class He {
  constructor({
    retain: e,
    release: t,
    methods: n
  } = {}) {
    /**
     * Represents the root node of the remote tree. This node is always defined,
     * and you will likely be most interested in its `children` property, which
     * contains the top-level elements of the remote tree.
     */
    M(this, "root", {
      id: x,
      type: Fe,
      children: [],
      version: 0,
      properties: {},
      attributes: {},
      eventListeners: {}
    });
    /**
     * An object that can synchronize a tree of elements between two JavaScript
     * environments. This object acts as a “thin waist”, allowing for efficient
     * communication of changes between a “remote” environment (usually, a JavaScript
     * sandbox, such as an `iframe` or Web Worker) and a “host” environment
     * (usually, a top-level browser page).
     */
    M(this, "attached", /* @__PURE__ */ new Map([[x, this.root]]));
    M(this, "subscribers", /* @__PURE__ */ new Map());
    M(this, "parents", /* @__PURE__ */ new Map());
    M(this, "implementations", /* @__PURE__ */ new Map());
    const {
      attached: i,
      parents: o,
      subscribers: a
    } = this;
    this.connection = ve({
      call: (s, c, ...l) => {
        const u = this.implementations.get(s), m = u == null ? void 0 : u[c];
        if (typeof m != "function")
          throw new Error(`Node ${s} does not implement the ${c}() method`);
        return m(...l);
      },
      insertChild: (s, c, l) => {
        const u = i.get(s), {
          children: m
        } = u, h = d(c, u);
        l === m.length ? m.push(h) : m.splice(l, 0, h), u.version += 1, this.parents.set(c.id, u.id), p(u);
      },
      removeChild: (s, c) => {
        const l = i.get(s), {
          children: u
        } = l, [m] = u.splice(c, 1);
        m && (l.version += 1, p(l), f(m));
      },
      updateProperty: (s, c, l, u = j) => {
        const m = i.get(s);
        e == null || e(l);
        let h;
        switch (u) {
          case j:
            h = m.properties;
            break;
          case te:
            h = m.attributes;
            break;
          case re:
            h = m.eventListeners;
            break;
        }
        const R = h[c];
        h[c] = l, m.version += 1;
        let y;
        if (c === "slot") {
          const w = this.parents.get(s);
          y = w == null ? w : i.get(w), y && (y.version += 1);
        }
        p(m), y && p(y), t == null || t(R);
      },
      updateText: (s, c) => {
        const l = i.get(s);
        l.data = c, l.version += 1, p(l);
      }
    }), n && this.implement(this.root, n);
    function p(s) {
      const c = a.get(s.id);
      if (c)
        for (const l of c)
          l(s);
    }
    function d(s, c) {
      let l;
      switch (s.type) {
        case Ee:
        case be: {
          const {
            id: u,
            type: m,
            data: h
          } = s;
          l = {
            id: u,
            type: m,
            data: h,
            version: 0
          };
          break;
        }
        case _e: {
          const {
            id: u,
            type: m,
            element: h,
            children: R,
            properties: y,
            attributes: w,
            eventListeners: I
          } = s;
          e == null || e(y), e == null || e(I);
          const O = [];
          l = {
            id: u,
            type: m,
            element: h,
            version: 0,
            children: O,
            properties: {
              ...y
            },
            attributes: {
              ...w
            },
            eventListeners: {
              ...I
            }
          };
          for (const Ce of R)
            O.push(d(Ce, l));
          break;
        }
        default:
          throw new Error(`Unknown node type: ${JSON.stringify(s)}`);
      }
      return i.set(l.id, l), o.set(l.id, c.id), l;
    }
    function f(s) {
      if (i.delete(s.id), o.delete(s.id), t && ("properties" in s && t(s.properties), "eventListeners" in s && t(s.eventListeners)), "children" in s)
        for (const c of s.children)
          f(c);
    }
  }
  /**
   * Fetches the latest state of a remote element that has been
   * received from the remote environment.
   *
   * @param node The remote node to fetch.
   * @returns The current state of the remote node, or `undefined` if the node is not connected to the remote tree.
   *
   * @example
   * import {RemoteReceiver} from '@remote-dom/core/receivers';
   *
   * const receiver = new RemoteReceiver();
   *
   * receiver.get(receiver.root) === receiver.root; // true
   */
  get({
    id: e
  }) {
    return this.attached.get(e);
  }
  /**
   * Lets you define how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)
   * are implemented for a particular element in the tree.
   *
   * @param node The remote node to subscribe for changes.
   * @param implementation A record containing the methods to expose for the passed node.
   *
   * @example
   * // In the host environment:
   * import {RemoteReceiver} from '@remote-dom/core/receivers';
   *
   * const receiver = new RemoteReceiver();
   *
   * receiver.implement(receiver.root, {
   *   alert(message) {
   *     window.alert(message);
   *   },
   * });
   *
   * // In the remote environment:
   * import {RemoteRootElement} from '@remote-dom/core/elements';
   *
   * customElements.define('remote-root', RemoteRootElement);
   *
   * const root = document.createElement('remote-root');
   * root.connect(receiver.connection);
   *
   * root.callRemoteMethod('alert', 'Hello, world!');
   */
  implement({
    id: e
  }, t) {
    t == null ? this.implementations.delete(e) : this.implementations.set(e, t);
  }
  /**
   * Allows you to subscribe to changes in a remote element. This includes
   * changes to the remote element’s properties and list of children, but
   * note that you will not receive updates for properties or children of
   * _nested_ elements.
   *
   * @param node The remote node to subscribe for changes.
   * @param subscriber A function that will be called with the updated node on each change.
   *
   * @example
   * import {RemoteReceiver} from '@remote-dom/core/receivers';
   *
   * const abort = new AbortController();
   * const receiver = new RemoteReceiver();
   *
   * // Subscribe to all changes in the top-level children, attached
   * // directly to the remote “root”.
   * receiver.subscribe(
   *   receiver.root,
   *   (root) => {
   *     console.log('Root changed!', root);
   *   },
   *   {signal: abort.signal},
   * );
   */
  subscribe({
    id: e
  }, t, {
    signal: n
  } = {}) {
    let i = this.subscribers.get(e);
    i == null && (i = /* @__PURE__ */ new Set(), this.subscribers.set(e, i)), i.add(t), n == null || n.addEventListener("abort", () => {
      i.delete(t), i.size === 0 && this.subscribers.delete(e);
    });
  }
}
const ie = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakMap();
class qe {
  constructor({
    root: e,
    retain: t,
    release: n,
    call: i,
    cache: o
  } = {}) {
    /**
     * The root element that will contain the host implementations of
     * all nodes attached to the remote tree. To connect the receiver to
     * a new element, call the `connect()` method.
     */
    /**
     * An object that can synchronize a tree of elements between two JavaScript
     * environments. This object acts as a “thin waist”, allowing for efficient
     * communication of changes between a “remote” environment (usually, a JavaScript
     * sandbox, such as an `iframe` or Web Worker) and a “host” environment
     * (usually, a top-level browser page).
     */
    M(this, "attached", /* @__PURE__ */ new Map());
    this.root = e ?? document.createDocumentFragment();
    const {
      attached: a
    } = this, p = /* @__PURE__ */ new Map();
    this.connection = ve({
      call: (s, c, ...l) => {
        const u = s === x && this.root.nodeType !== 11 ? this.root : a.get(s);
        return i ? i(u, c, ...l) : u[c](...l);
      },
      insertChild: (s, c, l) => {
        const u = s === x ? this.root : a.get(s), m = p.get(s);
        m && clearTimeout(m), u.insertBefore(d(c), u.childNodes[l] || null);
      },
      removeChild: (s, c) => {
        const u = (s === x ? this.root : a.get(s)).childNodes[c];
        if (u.remove(), o != null && o.maxAge) {
          const m = p.get(s);
          m && clearTimeout(m);
          const h = setTimeout(() => {
            f(u);
          }, o.maxAge);
          p.set(s, h);
        } else
          f(u);
      },
      updateProperty: (s, c, l, u = j) => {
        const m = a.get(s);
        t == null || t(l);
        const h = V.get(m), R = h[c];
        h[c] = l, W(m, c, l, u), n == null || n(R);
      },
      updateText: (s, c) => {
        const l = a.get(s);
        l.data = c;
      }
    });
    function d(s) {
      const c = a.get(s.id);
      if (c) return c;
      let l;
      switch (s.type) {
        case _e: {
          if (l = document.createElement(s.element), s.properties) {
            V.set(l, s.properties);
            for (const u of Object.keys(s.properties)) {
              const m = s.properties[u];
              t == null || t(m), W(l, u, m, j);
            }
          } else
            V.set(l, {});
          if (s.attributes)
            for (const u of Object.keys(s.attributes)) {
              const m = s.attributes[u];
              t == null || t(m), W(l, u, m, te);
            }
          if (ye.set(l, {}), s.eventListeners)
            for (const u of Object.keys(s.eventListeners)) {
              const m = s.eventListeners[u];
              t == null || t(m), W(l, u, m, re);
            }
          for (const u of s.children)
            l.appendChild(d(u));
          break;
        }
        case Ee: {
          l = document.createTextNode(s.data);
          break;
        }
        case be: {
          l = document.createComment(s.data);
          break;
        }
        default:
          throw new Error(`Unknown node type: ${JSON.stringify(s)}`);
      }
      return ie.set(l, s.id), a.set(s.id, l), l;
    }
    function f(s) {
      const c = ie.get(s);
      c && a.delete(c);
      const l = V.get(s);
      if (l && n && n(l), s instanceof Element)
        for (const u of s.childNodes)
          f(u);
    }
  }
  /**
   * Connects the receiver to a new root element. The representation of
   * any child elements of the remote root will be appended to this node
   * as children, and the `root` property will be updated to point to the
   * new element.
   */
  connect(e) {
    const t = this.root;
    this.root = e, t.childNodes.forEach((n) => {
      e.appendChild(n);
    });
  }
  /**
   * Disconnects the receiver from its current root element. Any current
   * children of the root element will be moved to a `DocumentFragment`
   * instead, so they can be re-attached to a new element later.
   */
  disconnect() {
    if (this.root.nodeType === 11) return this.root;
    const e = this.root, t = new DocumentFragment();
    return this.root = t, e.childNodes.forEach((n) => {
      t.appendChild(n);
    }), t;
  }
}
function W(r, e, t, n) {
  switch (n) {
    case j: {
      r[e] = t;
      break;
    }
    case te: {
      t == null ? r.removeAttribute(e) : r.setAttribute(e, t);
      break;
    }
    case re: {
      const i = ye.get(r), o = i == null ? void 0 : i[e];
      if (o && r.removeEventListener(e, o), t != null) {
        const a = (p) => {
          var f;
          if (p.target !== r) return;
          const d = t(p.detail);
          (f = p.resolve) == null || f.call(p, d);
        };
        i && (i[e] = a), r.addEventListener(e, a);
      }
      break;
    }
  }
}
function ne(r, e) {
  const [t, n] = Ue(() => {
    const o = e.get(r);
    return {
      id: r.id,
      version: o == null ? void 0 : o.version,
      value: o,
      receiver: e
    };
  });
  let i = t.value;
  if (t.receiver !== e || t.id !== r.id) {
    const o = e.get(r);
    i = o, n({
      receiver: e,
      id: r.id,
      version: o == null ? void 0 : o.version,
      value: i
    });
  }
  return xe(i), U(() => {
    const o = new AbortController(), a = () => {
      o.signal.aborted || n((p) => {
        const {
          id: d,
          version: f,
          receiver: s
        } = p, {
          id: c
        } = r;
        if (s !== e || d !== c)
          return p;
        const l = e.get(r), u = l == null ? void 0 : l.version;
        return f === u ? p : {
          receiver: e,
          value: l,
          id: c,
          version: u
        };
      });
    };
    return e.subscribe(r, a, {
      signal: o.signal
    }), a(), () => {
      o.abort();
    };
  }, [e, r.id]), i;
}
function Be({
  remote: r,
  receiver: e
}) {
  const t = ne(r, e);
  return t ? /* @__PURE__ */ E(B, {
    children: t.data
  }) : null;
}
function J(r, {
  receiver: e,
  components: t
}) {
  switch (r.type) {
    case 1: {
      const n = t.get(r.element);
      if (n == null)
        throw new Error(`No component found for remote element: ${r.element}`);
      return /* @__PURE__ */ E(n, {
        element: r,
        receiver: e,
        components: t
      }, r.id);
    }
    case 3:
      return /* @__PURE__ */ E(Be, {
        remote: r,
        receiver: e
      }, r.id);
    case 8:
      return null;
    default:
      throw new Error(`Unknown remote node type: ${String(r)}`);
  }
}
function $e(r, e) {
  if (!r) return;
  const {
    children: t,
    properties: n,
    attributes: i,
    eventListeners: o
  } = r, a = [], p = {
    ...n,
    ...i,
    children: a
  };
  if (e.eventProps)
    for (const [d, f] of Object.entries(e.eventProps)) {
      const s = f == null ? void 0 : f.event;
      if (s == null) continue;
      const c = o[s];
      c && (p[d] = se(c));
    }
  else
    for (const [d, f] of Object.entries(o))
      p[`on${d[0].toUpperCase()}${d.slice(1)}`] = se(f);
  for (const d of t)
    if (d.type === 1 && typeof d.attributes.slot == "string") {
      const f = d.attributes.slot, s = J(d, e);
      p[f] = p[f] ? /* @__PURE__ */ ee(B, {
        children: [p[f], s]
      }) : s;
    } else
      a.push(J(d, e));
  return p;
}
function se(r) {
  return function(...t) {
    if (t.length === 1 && t[0] instanceof Event) {
      const n = t[0];
      return n.target !== n.currentTarget ? void 0 : "detail" in n ? r(n.detail) : r();
    }
    return r(...t);
  };
}
const Ke = Symbol.for("remote-dom.element"), Ze = Symbol.for("remote-dom.element.attached");
function Je(r, {
  name: e,
  eventProps: t
} = {}) {
  const n = /* @__PURE__ */ ke(function({
    element: o,
    receiver: a,
    components: p
  }) {
    const d = k(), f = ne(o, a), s = f ?? o, c = s.id, l = $e(s, {
      receiver: a,
      components: p,
      eventProps: t
    });
    if (l[Ke] = s, l[Ze] = f != null, d.current == null) {
      const u = {
        id: c,
        receiver: a
      };
      u.instanceRef = Xe(u), d.current = u;
    }
    return d.current.id = c, d.current.receiver = a, U(() => {
      var m;
      const u = {
        id: c
      };
      return a.implement(u, (m = d.current) == null ? void 0 : m.instanceRef.current), () => {
        a.implement(u, null);
      };
    }, [c, a]), /* @__PURE__ */ E(r, {
      ref: d.current.instanceRef,
      ...l
    });
  });
  return n.displayName = e ?? `RemoteComponentRenderer(${r.displayName ?? r.name ?? "Component"})`, n;
}
function Xe(r) {
  let e = null;
  return {
    get current() {
      return e;
    },
    set current(t) {
      e = t, r.receiver.implement(r, t);
    }
  };
}
function Qe(r) {
  const {
    receiver: e
  } = r, {
    children: t
  } = ne(e.root, e);
  return /* @__PURE__ */ E(B, {
    children: t.map((n) => J(n, r))
  });
}
const et = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
</head>
<body>
  <div id="root"></div>
  <script>
"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteEvent.mjs
  var RemoteEvent = class extends CustomEvent {
    /**
     * The last value received from a \`respondWith()\` call.
     */
    /**
     * Provides the \`response\` value to be sent as the return value for
     * the remote property function that triggered this event.
     */
    respondWith(response) {
      this.response = response;
    }
  };

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/constants.mjs
  var MUTATION_TYPE_INSERT_CHILD = 0;
  var MUTATION_TYPE_REMOVE_CHILD = 1;
  var MUTATION_TYPE_UPDATE_TEXT = 2;
  var MUTATION_TYPE_UPDATE_PROPERTY = 3;
  var UPDATE_PROPERTY_TYPE_PROPERTY = 1;
  var UPDATE_PROPERTY_TYPE_ATTRIBUTE = 2;
  var UPDATE_PROPERTY_TYPE_EVENT_LISTENER = 3;
  var ROOT_ID = "~";

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/internals.mjs
  var REMOTE_CONNECTIONS = /* @__PURE__ */ new WeakMap();
  var REMOTE_IDS = /* @__PURE__ */ new WeakMap();
  var id = 0;
  function remoteId(node) {
    let remoteID = REMOTE_IDS.get(node);
    if (remoteID == null) {
      remoteID = String(id++);
      REMOTE_IDS.set(node, remoteID);
    }
    return remoteID;
  }
  var REMOTE_PROPERTIES = /* @__PURE__ */ new WeakMap();
  function remoteProperties(node) {
    return REMOTE_PROPERTIES.get(node);
  }
  var REMOTE_ATTRIBUTES = /* @__PURE__ */ new WeakMap();
  function remoteAttributes(node) {
    let attributes = REMOTE_ATTRIBUTES.get(node);
    if (attributes != null) return attributes;
    if (!(node instanceof Element) || node.tagName.includes("-")) return void 0;
    attributes = {};
    for (const {
      name,
      value
    } of node.attributes) {
      attributes[name] = value;
    }
    return attributes;
  }
  var REMOTE_EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
  function remoteEventListeners(node) {
    return REMOTE_EVENT_LISTENERS.get(node);
  }
  function updateRemoteElementProperty(node, property, value) {
    let properties = REMOTE_PROPERTIES.get(node);
    if (properties == null) {
      properties = {};
      REMOTE_PROPERTIES.set(node, properties);
    }
    if (properties[property] === value) return;
    properties[property] = value;
    const connection = REMOTE_CONNECTIONS.get(node);
    if (connection == null) return;
    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), property, value, UPDATE_PROPERTY_TYPE_PROPERTY]]);
  }
  function updateRemoteElementAttribute(node, attribute, value) {
    let attributes = REMOTE_ATTRIBUTES.get(node);
    if (attributes == null) {
      attributes = {};
      REMOTE_ATTRIBUTES.set(node, attributes);
    }
    if (attributes[attribute] === value) return;
    if (value == null) {
      delete attributes[attribute];
    } else {
      attributes[attribute] = String(value);
    }
    const connection = REMOTE_CONNECTIONS.get(node);
    if (connection == null) return;
    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), attribute, value, UPDATE_PROPERTY_TYPE_ATTRIBUTE]]);
  }
  function updateRemoteElementEventListener(node, event, listener) {
    let eventListeners = REMOTE_EVENT_LISTENERS.get(node);
    if (eventListeners == null) {
      eventListeners = {};
      REMOTE_EVENT_LISTENERS.set(node, eventListeners);
    }
    if (eventListeners[event] === listener) return;
    if (listener == null) {
      delete eventListeners[event];
    } else {
      eventListeners[event] = listener;
    }
    const connection = REMOTE_CONNECTIONS.get(node);
    if (connection == null) return;
    connection.mutate([[MUTATION_TYPE_UPDATE_PROPERTY, remoteId(node), event, listener, UPDATE_PROPERTY_TYPE_EVENT_LISTENER]]);
  }
  function connectRemoteNode(node, connection) {
    const existingConnection = REMOTE_CONNECTIONS.get(node);
    if (existingConnection === connection) return;
    REMOTE_CONNECTIONS.set(node, connection);
    if (node.childNodes) {
      for (let i = 0; i < node.childNodes.length; i++) {
        connectRemoteNode(node.childNodes[i], connection);
      }
    }
  }
  function disconnectRemoteNode(node) {
    const existingConnection = REMOTE_CONNECTIONS.get(node);
    if (existingConnection == null) return;
    REMOTE_CONNECTIONS.delete(node);
    if (node.childNodes) {
      for (let i = 0; i < node.childNodes.length; i++) {
        disconnectRemoteNode(node.childNodes[i]);
      }
    }
  }
  function serializeRemoteNode(node) {
    const {
      nodeType
    } = node;
    switch (nodeType) {
      // Element
      case 1: {
        return {
          id: remoteId(node),
          type: nodeType,
          element: node.localName,
          properties: cloneMaybeObject(remoteProperties(node)),
          attributes: cloneMaybeObject(remoteAttributes(node)),
          eventListeners: cloneMaybeObject(remoteEventListeners(node)),
          children: Array.from(node.childNodes).map(serializeRemoteNode)
        };
      }
      // TextNode
      case 3:
      // Comment
      // eslint-disable-next-line no-fallthrough
      case 8: {
        return {
          id: remoteId(node),
          type: nodeType,
          data: node.data
        };
      }
      default: {
        throw new Error(\`Cannot serialize node of type \${node.nodeType} (\${typeof node.nodeType})\`);
      }
    }
  }
  function cloneMaybeObject(maybeObject) {
    return maybeObject ? {
      ...maybeObject
    } : void 0;
  }
  function callRemoteElementMethod(node, method, ...args) {
    const id2 = REMOTE_IDS.get(node);
    const connection = REMOTE_CONNECTIONS.get(node);
    if (id2 == null || connection == null) {
      throw new Error(\`Cannot call method \${method} on an unconnected node\`);
    }
    return connection.call(id2, method, ...args);
  }

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteElement.mjs
  var EMPTY_DEFINITION = Object.freeze({});
  var RemoteElement = class extends HTMLElement {
    static get observedAttributes() {
      return this.finalize().__observedAttributes;
    }
    /**
     * The resolved property definitions for this remote element.
     */
    static get remotePropertyDefinitions() {
      return this.finalize().__remotePropertyDefinitions;
    }
    /**
     * The resolved attribute definitions for this remote element.
     */
    static get remoteAttributeDefinitions() {
      return this.finalize().__remoteAttributeDefinitions;
    }
    /**
     * The resolved event listener definitions for this remote element.
     */
    static get remoteEventDefinitions() {
      return this.finalize().__remoteEventDefinitions;
    }
    /**
     * The resolved slot definitions for this remote element.
     */
    static get remoteSlotDefinitions() {
      return this.finalize().__remoteSlotDefinitions;
    }
    /**
     * Creates a new definition for a property that will be synchronized between
     * this remote element and its host representation.
     */
    static createProperty(name, definition) {
      saveRemoteProperty(name, definition, this.observedAttributes, this.remotePropertyDefinitions, this.__attributeToPropertyMap, this.__eventToPropertyMap);
    }
    /**
     * Consumes all the static members defined on the class and converts them
     * into the internal representation used to handle properties, attributes,
     * and event listeners.
     */
    static finalize() {
      if (this.hasOwnProperty("__finalized")) {
        return this;
      }
      this.__finalized = true;
      const {
        slottable,
        remoteSlots,
        remoteProperties: remoteProperties2,
        remoteAttributes: remoteAttributes2,
        remoteEvents,
        remoteMethods
      } = this;
      const SuperConstructor = Object.getPrototypeOf(this);
      const observedAttributes = /* @__PURE__ */ new Set();
      if (slottable) observedAttributes.add("slot");
      const attributeToPropertyMap = /* @__PURE__ */ new Map();
      const eventToPropertyMap = /* @__PURE__ */ new Map();
      const remoteSlotDefinitions = /* @__PURE__ */ new Map();
      const remotePropertyDefinitions = /* @__PURE__ */ new Map();
      const remoteAttributeDefinitions = /* @__PURE__ */ new Map();
      const remoteEventDefinitions = /* @__PURE__ */ new Map();
      if (typeof SuperConstructor.finalize === "function") {
        SuperConstructor.finalize();
        SuperConstructor.observedAttributes.forEach((attribute) => {
          observedAttributes.add(attribute);
        });
        SuperConstructor.remotePropertyDefinitions.forEach((definition, property) => {
          remotePropertyDefinitions.set(property, definition);
        });
        SuperConstructor.remoteAttributeDefinitions.forEach((definition, event) => {
          remoteAttributeDefinitions.set(event, definition);
        });
        SuperConstructor.remoteEventDefinitions.forEach((definition, event) => {
          remoteEventDefinitions.set(event, definition);
        });
        SuperConstructor.remoteSlotDefinitions.forEach((definition, slot) => {
          remoteSlotDefinitions.set(slot, definition);
        });
      }
      if (remoteSlots != null) {
        const slotNames = Array.isArray(remoteSlots) ? remoteSlots : Object.keys(remoteSlots);
        slotNames.forEach((slotName) => {
          remoteSlotDefinitions.set(slotName, EMPTY_DEFINITION);
        });
      }
      if (remoteProperties2 != null) {
        if (Array.isArray(remoteProperties2)) {
          remoteProperties2.forEach((propertyName) => {
            saveRemoteProperty(propertyName, void 0, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);
          });
        } else {
          Object.keys(remoteProperties2).forEach((propertyName) => {
            saveRemoteProperty(propertyName, remoteProperties2[propertyName], observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap);
          });
        }
      }
      if (remoteAttributes2 != null) {
        remoteAttributes2.forEach((attribute) => {
          remoteAttributeDefinitions.set(attribute, EMPTY_DEFINITION);
          observedAttributes.add(attribute);
        });
      }
      if (remoteEvents != null) {
        if (Array.isArray(remoteEvents)) {
          remoteEvents.forEach((event) => {
            remoteEventDefinitions.set(event, EMPTY_DEFINITION);
          });
        } else {
          Object.keys(remoteEvents).forEach((event) => {
            remoteEventDefinitions.set(event, remoteEvents[event]);
          });
        }
      }
      if (remoteMethods != null) {
        if (Array.isArray(remoteMethods)) {
          for (const method of remoteMethods) {
            this.prototype[method] = function(...args) {
              return this.callRemoteMethod(method, ...args);
            };
          }
        } else {
          Object.assign(this, remoteMethods);
        }
      }
      Object.defineProperties(this, {
        __observedAttributes: {
          value: [...observedAttributes],
          enumerable: false
        },
        __remoteSlotDefinitions: {
          value: remoteSlotDefinitions,
          enumerable: false
        },
        __remotePropertyDefinitions: {
          value: remotePropertyDefinitions,
          enumerable: false
        },
        __remoteAttributeDefinitions: {
          value: remoteAttributeDefinitions,
          enumerable: false
        },
        __remoteEventDefinitions: {
          value: remoteEventDefinitions,
          enumerable: false
        },
        __attributeToPropertyMap: {
          value: attributeToPropertyMap,
          enumerable: false
        },
        __eventToPropertyMap: {
          value: eventToPropertyMap,
          enumerable: false
        }
      });
      return this;
    }
    // Just need to use these types so TS doesn’t lose track of them.
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor() {
      super();
      this.constructor.finalize();
      const propertyDescriptors = {};
      const initialPropertiesToSet = {};
      const prototype = Object.getPrototypeOf(this);
      const ThisClass = this.constructor;
      for (const [property, description] of ThisClass.remotePropertyDefinitions.entries()) {
        const aliasedName = description.name;
        if (prototype.hasOwnProperty(property)) {
          continue;
        }
        if (property === aliasedName) {
          initialPropertiesToSet[property] = description.default;
        }
        const propertyDescriptor = {
          configurable: true,
          enumerable: property === aliasedName,
          get: () => {
            return remoteProperties(this)?.[aliasedName];
          },
          set: (value) => {
            updateRemoteElementProperty(this, aliasedName, value);
          }
        };
        propertyDescriptors[property] = propertyDescriptor;
      }
      for (const [event, definition] of ThisClass.remoteEventDefinitions.entries()) {
        const propertyFromDefinition = definition.property ?? true;
        if (!propertyFromDefinition) continue;
        const property = propertyFromDefinition === true ? \`on\${event}\` : propertyFromDefinition;
        propertyDescriptors[property] = {
          configurable: true,
          enumerable: true,
          get: () => {
            return getRemoteEvents(this).properties.get(property) ?? null;
          },
          set: (value) => {
            const remoteEvents = getRemoteEvents(this);
            const currentListener = remoteEvents.properties.get(property);
            if (typeof value === "function") {
              let handler = function(...args) {
                return value.call(this, ...args);
              };
              remoteEvents.properties.set(property, handler);
              this.addEventListener(event, handler);
            } else {
              remoteEvents.properties.delete(property);
            }
            if (currentListener) {
              this.removeEventListener(event, currentListener);
            }
          }
        };
      }
      Object.defineProperties(this, propertyDescriptors);
      Object.assign(this, initialPropertiesToSet);
    }
    attributeChangedCallback(attribute, _oldValue, newValue) {
      if (attribute === "slot" && this.constructor.slottable) {
        updateRemoteElementAttribute(this, attribute, newValue ? String(newValue) : void 0);
        return;
      }
      const {
        remotePropertyDefinitions,
        remoteAttributeDefinitions,
        __attributeToPropertyMap: attributeToPropertyMap
      } = this.constructor;
      if (remoteAttributeDefinitions.has(attribute)) {
        updateRemoteElementAttribute(this, attribute, newValue);
        return;
      }
      const property = attributeToPropertyMap.get(attribute);
      const propertyDefinition = property == null ? property : remotePropertyDefinitions.get(property);
      if (propertyDefinition == null) return;
      this[property] = convertAttributeValueToProperty(newValue, propertyDefinition.type);
    }
    connectedCallback() {
      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {
        if (descriptor.bubbles) {
          this.addEventListener(event, noopBubblesEventListener);
        }
      }
    }
    disconnectedCallback() {
      for (const [event, descriptor] of this.constructor.remoteEventDefinitions.entries()) {
        if (descriptor.bubbles) {
          this.removeEventListener(event, noopBubblesEventListener);
        }
      }
    }
    addEventListener(type, listener, options) {
      const {
        remoteEventDefinitions,
        __eventToPropertyMap: eventToPropertyMap
      } = this.constructor;
      const listenerDefinition = remoteEventDefinitions.get(type);
      const property = eventToPropertyMap.get(type);
      if (listenerDefinition == null && property == null) {
        return super.addEventListener(type, listener, options);
      }
      const remoteEvents = getRemoteEvents(this);
      const remoteEvent = getRemoteEventRecord.call(this, type, {
        property,
        definition: listenerDefinition
      });
      const normalizedListener = typeof options === "object" && options?.once ? (...args) => {
        const result = typeof listener === "object" ? listener.handleEvent(...args) : listener.call(this, ...args);
        removeRemoteListener.call(this, type, listener, listenerRecord);
        return result;
      } : listener;
      const listenerRecord = [normalizedListener, remoteEvent];
      remoteEvent.listeners.add(listener);
      remoteEvents.listeners.set(listener, listenerRecord);
      super.addEventListener(type, normalizedListener, options);
      if (typeof options === "object" && options.signal) {
        options.signal.addEventListener("abort", () => {
          removeRemoteListener.call(this, type, listener, listenerRecord);
        }, {
          once: true
        });
      }
      if (listenerDefinition) {
        updateRemoteElementEventListener(this, type, remoteEvent.dispatch);
      } else {
        updateRemoteElementProperty(this, property, remoteEvent.dispatch);
      }
    }
    removeEventListener(type, listener, options) {
      const listenerRecord = REMOTE_EVENTS.get(this)?.listeners.get(listener);
      const normalizedListener = listenerRecord ? listenerRecord[0] : listener;
      super.removeEventListener(type, normalizedListener, options);
      if (listenerRecord == null) return;
      removeRemoteListener.call(this, type, listener, listenerRecord);
    }
    /**
     * Updates a single remote property on an element node. If the element is
     * connected to a remote root, this function will also make a \`mutate()\` call
     * to communicate the change to the host.
     */
    updateRemoteProperty(name, value) {
      updateRemoteElementProperty(this, name, value);
    }
    /**
     * Updates a single remote attribute on an element node. If the element is
     * connected to a remote root, this function will also make a \`mutate()\` call
     * to communicate the change to the host.
     */
    updateRemoteAttribute(name, value) {
      updateRemoteElementAttribute(this, name, value);
    }
    /**
     * Performs a method through \`RemoteConnection.call()\`, using the remote ID and
     * connection for the provided node.
     */
    callRemoteMethod(method, ...args) {
      return callRemoteElementMethod(this, method, ...args);
    }
  };
  __publicField(RemoteElement, "slottable", true);
  __publicField(RemoteElement, "__finalized", true);
  __publicField(RemoteElement, "__observedAttributes", []);
  __publicField(RemoteElement, "__attributeToPropertyMap", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__eventToPropertyMap", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remotePropertyDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remoteAttributeDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remoteEventDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  __publicField(RemoteElement, "__remoteSlotDefinitions", /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
  var REMOTE_EVENTS = /* @__PURE__ */ new WeakMap();
  function getRemoteEvents(element) {
    let events = REMOTE_EVENTS.get(element);
    if (events) return events;
    events = {
      events: /* @__PURE__ */ new Map(),
      properties: /* @__PURE__ */ new Map(),
      listeners: /* @__PURE__ */ new WeakMap()
    };
    REMOTE_EVENTS.set(element, events);
    return events;
  }
  function getRemoteEventRecord(type, {
    property,
    definition
  }) {
    const remoteEvents = getRemoteEvents(this);
    let remoteEvent = remoteEvents.events.get(type);
    if (remoteEvent == null) {
      remoteEvent = {
        name: type,
        property,
        definition,
        listeners: /* @__PURE__ */ new Set(),
        dispatch: (arg) => {
          const event = definition?.dispatchEvent?.call(this, arg) ?? new RemoteEvent(type, {
            detail: arg,
            bubbles: definition?.bubbles
          });
          this.dispatchEvent(event);
          return event.response;
        }
      };
      remoteEvents.events.set(type, remoteEvent);
    }
    return remoteEvent;
  }
  function removeRemoteListener(type, listener, listenerRecord) {
    const remoteEvents = getRemoteEvents(this);
    const remoteEvent = listenerRecord[1];
    remoteEvent.listeners.delete(listener);
    remoteEvents.listeners.delete(listener);
    if (remoteEvent.listeners.size > 0) return;
    remoteEvents.events.delete(type);
    if (remoteEvent.property) {
      if (remoteProperties(this)?.[remoteEvent.property] === remoteEvent.dispatch) {
        updateRemoteElementProperty(this, remoteEvent.property, void 0);
      }
    } else {
      if (remoteEventListeners(this)?.[type] === remoteEvent.dispatch) {
        updateRemoteElementEventListener(this, type, void 0);
      }
    }
  }
  function saveRemoteProperty(name, description, observedAttributes, remotePropertyDefinitions, attributeToPropertyMap, eventToPropertyMap) {
    if (remotePropertyDefinitions.has(name)) {
      return remotePropertyDefinitions.get(name);
    }
    const looksLikeEventCallback = name[0] === "o" && name[1] === "n";
    const resolvedDescription = description ?? {};
    let {
      alias
    } = resolvedDescription;
    const {
      type = looksLikeEventCallback ? Function : String,
      attribute = type !== Function,
      event = looksLikeEventCallback,
      default: defaultValue = type === Boolean ? false : void 0
    } = resolvedDescription;
    if (alias == null) {
      const lowercaseProperty = name.toLowerCase();
      if (lowercaseProperty !== name) {
        alias = [lowercaseProperty];
      }
      if (looksLikeEventCallback) {
        alias ?? (alias = []);
        alias.unshift(\`_\${name}\`);
      }
    }
    let attributeName;
    if (attribute === true) {
      attributeName = camelToKebabCase(name);
    } else if (typeof attribute === "string") {
      attributeName = attribute;
    }
    if (attributeName) {
      if (Array.isArray(observedAttributes)) {
        observedAttributes.push(attributeName);
      } else {
        observedAttributes.add(attributeName);
      }
      attributeToPropertyMap.set(attributeName, name);
    }
    let eventName;
    if (event === true) {
      eventName = camelToKebabCase(looksLikeEventCallback ? name.slice(2) : name);
    } else if (typeof event === "string") {
      eventName = event;
    }
    if (eventName) {
      eventToPropertyMap.set(eventName, name);
    }
    const definition = {
      name,
      type,
      alias,
      event: eventName,
      attribute: attributeName,
      default: defaultValue
    };
    remotePropertyDefinitions.set(name, definition);
    if (alias) {
      for (const propertyAlias of alias) {
        remotePropertyDefinitions.set(propertyAlias, definition);
      }
    }
    return definition;
  }
  function convertAttributeValueToProperty(value, type) {
    if (value == null) return void 0;
    switch (type) {
      case Boolean:
        return value != null && value !== "false";
      case Object:
      case Array:
        try {
          return JSON.parse(value);
        } catch {
          return void 0;
        }
      case String:
        return String(value);
      case Number:
        return Number.parseFloat(value);
      case Function:
        return void 0;
      default: {
        return type.parse?.(value);
      }
    }
  }
  function camelToKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function noopBubblesEventListener() {
  }

  // ../../node_modules/.pnpm/@remote-dom+core@1.8.1_@preact+signals-core@1.10.0/node_modules/@remote-dom/core/build/esm/elements/RemoteMutationObserver.mjs
  var RemoteMutationObserver = class extends MutationObserver {
    constructor(connection) {
      super((records) => {
        const addedNodes = [];
        const remoteRecords = [];
        for (const record of records) {
          const targetId = remoteId(record.target);
          if (record.type === "childList") {
            const position = record.previousSibling ? indexOf(record.previousSibling, record.target.childNodes) + 1 : 0;
            record.removedNodes.forEach((node) => {
              disconnectRemoteNode(node);
              remoteRecords.push([MUTATION_TYPE_REMOVE_CHILD, targetId, position]);
            });
            record.addedNodes.forEach((node, index) => {
              if (addedNodes.some((addedNode) => {
                return addedNode === node || addedNode.contains(node);
              })) {
                return;
              }
              addedNodes.push(node);
              connectRemoteNode(node, connection);
              remoteRecords.push([MUTATION_TYPE_INSERT_CHILD, targetId, serializeRemoteNode(node), position + index]);
            });
          } else if (record.type === "characterData") {
            remoteRecords.push([MUTATION_TYPE_UPDATE_TEXT, targetId, record.target.textContent ?? ""]);
          } else if (record.type === "attributes" && record.attributeName != null && record.target instanceof Element && !record.target.tagName.includes("-")) {
            remoteRecords.push([MUTATION_TYPE_UPDATE_PROPERTY, targetId, record.attributeName, record.target.getAttribute(record.attributeName)]);
          }
        }
        connection.mutate(remoteRecords);
      });
      this.connection = connection;
    }
    /**
     * Starts watching changes to the element, and communicates changes to the
     * host environment. By default, this method will also communicate any initial
     * children of the element to the host environment.
     */
    observe(target, options) {
      REMOTE_IDS.set(target, ROOT_ID);
      if (options?.initial !== false && target.childNodes.length > 0) {
        const records = [];
        for (let i = 0; i < target.childNodes.length; i++) {
          const node = target.childNodes[i];
          connectRemoteNode(node, this.connection);
          records.push([MUTATION_TYPE_INSERT_CHILD, ROOT_ID, serializeRemoteNode(node), i]);
        }
        this.connection.mutate(records);
      }
      super.observe(target, {
        subtree: true,
        childList: true,
        attributes: true,
        characterData: true,
        ...options
      });
    }
  };
  function indexOf(node, list) {
    for (let i = 0; i < list.length; i++) {
      if (list[i] === node) return i;
    }
    return -1;
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/constants.mjs
  var MESSAGE_CALL = 1;
  var MESSAGE_CALL_RESULT = 2;
  var MESSAGE_FUNCTION_CALL = 3;
  var MESSAGE_FUNCTION_RESULT = 4;
  var MESSAGE_FUNCTION_RELEASE = 5;
  var SERIALIZE_METHOD = Symbol.for("quilt.threads.serialize");
  var TRANSFERABLE = Symbol.for("quilt.threads.transferable");

  // ../../node_modules/.pnpm/@quilted+events@2.1.3/node_modules/@quilted/events/build/esm/abort/NestedAbortController.mjs
  var NestedAbortController = class extends AbortController {
    constructor(...parents) {
      super();
      const abortedSignal = parents.find((signal) => signal.aborted);
      if (abortedSignal) {
        this.abort(abortedSignal.reason);
      } else {
        const abort = (event) => this.abort(event.target.reason);
        const options = {
          signal: this.signal
        };
        for (const signal of parents) {
          signal.addEventListener("abort", abort, options);
        }
      }
    }
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/errors.mjs
  var ThreadClosedError = class extends Error {
    constructor() {
      super("You attempted to call a function on a closed thread.");
    }
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/nanoid.mjs
  var a = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  function nanoid(e = 21) {
    let t = "", r = crypto.getRandomValues(new Uint8Array(e));
    for (let n = 0; n < e; n++) t += a[63 & r[n]];
    return t;
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/functions/ThreadFunctionsAutomatic.mjs
  var _functionsToId, _idsToFunction, _idsToProxy, _finalization, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn;
  var ThreadFunctionsAutomatic = class {
    constructor() {
      __privateAdd(this, _ThreadFunctionsAutomatic_instances);
      __privateAdd(this, _functionsToId, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      __privateAdd(this, _idsToFunction, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      __privateAdd(this, _idsToProxy, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      __privateAdd(this, _finalization, /* @__PURE__ */ (() => /* @__PURE__ */ new WeakMap())());
    }
    get(id2) {
      return __privateGet(this, _idsToFunction).get(id2);
    }
    release(id2) {
      const func = __privateGet(this, _idsToFunction).get(id2);
      if (func) {
        __privateGet(this, _idsToFunction).delete(id2);
        __privateGet(this, _functionsToId).delete(func);
      }
      return Boolean(func);
    }
    serialize(func) {
      let id2 = __privateGet(this, _functionsToId).get(func);
      if (id2 == null) {
        id2 = nanoid();
        __privateGet(this, _functionsToId).set(func, id2);
        __privateGet(this, _idsToFunction).set(id2, func);
      }
      return id2;
    }
    deserialize(id2, thread) {
      let proxy = __privateGet(this, _idsToProxy).get(id2)?.deref();
      if (proxy) return proxy;
      proxy = (...args) => {
        if (!__privateGet(this, _idsToProxy).has(id2)) {
          throw new Error("You attempted to call a function that was already revoked.");
        }
        return thread.call((callID, args2, transferable) => {
          thread.messages.send([MESSAGE_FUNCTION_CALL, callID, id2, args2], transferable);
        }, args);
      };
      __privateMethod(this, _ThreadFunctionsAutomatic_instances, finalizationRegistry_fn).call(this, thread)?.register(proxy, id2);
      __privateGet(this, _idsToProxy).set(id2, new WeakRef(proxy));
      return proxy;
    }
  };
  _functionsToId = new WeakMap();
  _idsToFunction = new WeakMap();
  _idsToProxy = new WeakMap();
  _finalization = new WeakMap();
  _ThreadFunctionsAutomatic_instances = new WeakSet();
  finalizationRegistry_fn = function(thread) {
    let finalization = __privateGet(this, _finalization).get(thread);
    if (typeof FinalizationRegistry === "undefined") {
      return void 0;
    }
    if (!finalization) {
      finalization = new FinalizationRegistry((id2) => {
        thread.messages.send([MESSAGE_FUNCTION_RELEASE, id2]);
      });
      __privateGet(this, _finalization).set(thread, finalization);
    }
    return finalization;
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/shared.mjs
  function isIterator(value) {
    return value != null && (Symbol.asyncIterator in value || Symbol.iterator in value) && typeof value.next === "function";
  }
  function isBasicObject(value) {
    if (value == null || typeof value !== "object") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype == null || prototype === Object.prototype;
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/serialization/ThreadSerializationStructuredClone.mjs
  var FUNCTION = "_@f";
  var ASYNC_ITERATOR = "_@i";
  var _customSerializer, _customDeserializer, _ThreadSerializationStructuredClone_instances, serializeInternal_fn, deserializeInternal_fn;
  var ThreadSerializationStructuredClone = class {
    constructor(options) {
      __privateAdd(this, _ThreadSerializationStructuredClone_instances);
      __privateAdd(this, _customSerializer);
      __privateAdd(this, _customDeserializer);
      __privateSet(this, _customSerializer, options?.serialize);
      __privateSet(this, _customDeserializer, options?.deserialize);
    }
    /**
     * Serializes a value into a structured cloning-compatible format that can be transferred between threads.
     */
    serialize(value, thread, transferable) {
      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value, thread, transferable);
    }
    /**
     * Deserializes a structured cloning-compatible value from another thread.
     */
    deserialize(value, thread) {
      return __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value, thread);
    }
  };
  _customSerializer = new WeakMap();
  _customDeserializer = new WeakMap();
  _ThreadSerializationStructuredClone_instances = new WeakSet();
  serializeInternal_fn = function(value, thread, transferable, seen = /* @__PURE__ */ new Map(), isApplyingDefault = false) {
    if (value == null) return value;
    if (seen.has(value)) return seen.get(value);
    seen.set(value, void 0);
    if (typeof value === "object") {
      if (__privateGet(this, _customSerializer) && !isApplyingDefault) {
        const customValue = __privateGet(this, _customSerializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen, true), thread, transferable);
        if (customValue !== void 0) {
          seen.set(value, customValue);
          return customValue;
        }
      }
      if (value[TRANSFERABLE]) {
        transferable?.push(value);
        seen.set(value, value);
        return value;
      }
      const serializeValue = (value2) => {
        return __privateMethod(this, _ThreadSerializationStructuredClone_instances, serializeInternal_fn).call(this, value2, thread, transferable, seen);
      };
      if (typeof value[SERIALIZE_METHOD] === "function") {
        const result = value[SERIALIZE_METHOD]({
          serialize: serializeValue
        });
        seen.set(value, result);
        return result;
      }
      if (Array.isArray(value)) {
        const result = value.map((item) => serializeValue(item));
        seen.set(value, result);
        return result;
      }
      if (value instanceof Map) {
        const entries = [...value.entries()].map(([key, value2]) => {
          return [serializeValue(key), serializeValue(value2)];
        });
        const result = new Map(entries);
        seen.set(value, result);
        return result;
      }
      if (value instanceof Set) {
        const entries = [...value].map((entry) => serializeValue(entry));
        const result = new Set(entries);
        seen.set(value, result);
        return result;
      }
      const valueIsIterator = isIterator(value);
      if (isBasicObject(value) || valueIsIterator) {
        const result = {};
        for (const key of Object.keys(value)) {
          result[key] = serializeValue(value[key]);
        }
        if (valueIsIterator) {
          result.next ?? (result.next = serializeValue(value.next.bind(value)));
          result.return ?? (result.return = serializeValue(value.return.bind(value)));
          result.throw ?? (result.throw = serializeValue(value.throw.bind(value)));
          result[ASYNC_ITERATOR] = true;
        }
        seen.set(value, result);
        return result;
      }
    }
    if (typeof value === "function") {
      const serialized = thread.functions.serialize(value, thread, transferable);
      const result = {
        [FUNCTION]: serialized
      };
      seen.set(value, result);
      return result;
    }
    seen.set(value, value);
    return value;
  };
  deserializeInternal_fn = function(value, thread, isApplyingDefault = false) {
    if (value == null) return value;
    if (typeof value === "object") {
      if (__privateGet(this, _customDeserializer) && !isApplyingDefault) {
        const customValue = __privateGet(this, _customDeserializer).call(this, value, (value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread, true), thread);
        if (customValue !== void 0) {
          return customValue;
        }
      }
      if (value == null) {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((value2) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread));
      }
      if (value instanceof Map) {
        return new Map([...value].map(([key, value2]) => [__privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, key, thread), __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value2, thread)]));
      }
      if (value instanceof Set) {
        return new Set([...value].map((entry) => __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, entry, thread)));
      }
      if (FUNCTION in value) {
        const func = thread.functions.deserialize(value[FUNCTION], thread);
        return func;
      }
      if (!isBasicObject(value)) {
        return value;
      }
      const result = {};
      for (const key of Object.keys(value)) {
        if (key === ASYNC_ITERATOR) {
          result[Symbol.asyncIterator] = () => result;
        } else {
          result[key] = __privateMethod(this, _ThreadSerializationStructuredClone_instances, deserializeInternal_fn).call(this, value[key], thread);
        }
      }
      return result;
    }
    return value;
  };

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/Thread.mjs
  var _abort, _idsToResolver, _Thread_instances, callLocal_fn, handlerForCall_fn, resolveCall_fn, waitForResult_fn;
  var Thread = class {
    constructor(messages, {
      imports,
      exports,
      functions = new ThreadFunctionsAutomatic(),
      serialization = new ThreadSerializationStructuredClone(),
      signal
    } = {}) {
      __privateAdd(this, _Thread_instances);
      __privateAdd(this, _abort);
      __privateAdd(this, _idsToResolver, /* @__PURE__ */ (() => /* @__PURE__ */ new Map())());
      this.messages = messages;
      __privateSet(this, _abort, signal ? new NestedAbortController(signal) : new AbortController());
      this.exports = exports ?? {};
      this.imports = createThreadImports(__privateMethod(this, _Thread_instances, handlerForCall_fn).bind(this), imports);
      this.functions = functions;
      this.serialization = serialization;
      this.functions.start?.(this);
      this.serialization.start?.(this);
      this.signal.addEventListener("abort", () => {
        for (const id2 of __privateGet(this, _idsToResolver).keys()) {
          __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, id2, void 0, new ThreadClosedError());
        }
        __privateGet(this, _idsToResolver).clear();
      }, {
        once: true
      });
      messages.listen(async (rawData) => {
        const isThreadMessageData = Array.isArray(rawData) && typeof rawData[0] === "number";
        if (!isThreadMessageData) {
          return;
        }
        const data = rawData;
        switch (data[0]) {
          case MESSAGE_CALL: {
            const [, id2, property, args] = data;
            const func = this.exports[property] ?? (() => {
              throw new Error(\`No '\${property}' method is exported from this thread\`);
            });
            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {
              this.messages.send([MESSAGE_CALL_RESULT, id2, value, error], transferable);
            });
            break;
          }
          case MESSAGE_FUNCTION_CALL: {
            const [, callID, funcID, args] = data;
            const func = this.functions.get(funcID, this) ?? missingThreadFunction;
            await __privateMethod(this, _Thread_instances, callLocal_fn).call(this, func, args, (value, error, transferable) => {
              this.messages.send([MESSAGE_FUNCTION_RESULT, callID, value, error], transferable);
            });
            break;
          }
          case MESSAGE_CALL_RESULT:
          case MESSAGE_FUNCTION_RESULT: {
            __privateMethod(this, _Thread_instances, resolveCall_fn).call(this, ...data.slice(1));
            break;
          }
          case MESSAGE_FUNCTION_RELEASE: {
            const id2 = data[1];
            this.functions.release(id2, this);
            break;
          }
        }
      }, {
        signal: this.signal
      });
    }
    /**
     * An object that exposes the methods that can be called on the paired thread.
     * This object will automatically encode and decode arguments and return values
     * as necessary.
     */
    /**
     * An object that exposes the methods that can be called on this thread by the
     * paired thread. To set these methods, pass the \`exports\` option when creating
     * a new \`Thread\`.
     */
    /**
     * An object that provides the message-passing interface that allows communication
     * to flow between environments.
     */
    /**
     * An object that manages how functions are proxied between threads.
     */
    /**
     * An object that manages how values are serialized and deserialized between threads.
     */
    /**
     * An \`AbortSignal\` that indicates whether the communication channel is still open.
     */
    get signal() {
      return __privateGet(this, _abort).signal;
    }
    /**
     * A boolean indicating whether the communication channel is still open.
     */
    get closed() {
      return __privateGet(this, _abort).signal.aborted;
    }
    /**
     * Closes the communication channel between the two threads. This will prevent
     * any further communication between the threads, and will clean up any memory
     * associated with in-progress communication. It will also reject any inflight
     * function calls between threads with a \`ThreadClosedError\`.
     */
    close() {
      __privateGet(this, _abort).abort();
    }
    /**
     * Requests that the thread provide the context needed to make a function
     * call between threads. You provide this method a function to call and the
     * unserialized arguments you wish to call it with, and the thread will call
     * the function you provided with a serialized call ID, the serialized arguments,
     * and any transferable objects that need to be passed between threads.
     */
    call(func, args) {
      if (this.closed) {
        return Promise.reject(new ThreadClosedError());
      }
      const transferable = [];
      const serialized = this.serialization.serialize(args, this, transferable);
      const id2 = nanoid();
      const done = __privateMethod(this, _Thread_instances, waitForResult_fn).call(this, id2);
      func(id2, serialized, transferable);
      return done;
    }
  };
  _abort = new WeakMap();
  _idsToResolver = new WeakMap();
  _Thread_instances = new WeakSet();
  callLocal_fn = async function(func, args, withResult) {
    try {
      const result = this.functions.call ? await this.functions.call(func, args, this) : await func(...this.serialization.deserialize(args, this));
      const transferable = [];
      const serialized = this.serialization.serialize(result, this, transferable);
      withResult(serialized, void 0, transferable);
    } catch (error) {
      withResult(void 0, this.serialization.serialize(error, this));
    }
  };
  handlerForCall_fn = function(property) {
    return (...args) => {
      try {
        if (typeof property !== "string" && typeof property !== "number") {
          throw new Error(\`Can’t call a symbol method on a thread: \${property.toString()}\`);
        }
        return this.call((id2, serializedArgs, transferable) => {
          this.messages.send([MESSAGE_CALL, id2, property, serializedArgs], transferable);
        }, args);
      } catch (error) {
        return Promise.reject(error);
      }
    };
  };
  resolveCall_fn = function(...args) {
    const callID = args[0];
    const resolver = __privateGet(this, _idsToResolver).get(callID);
    if (resolver) {
      resolver(...args);
      __privateGet(this, _idsToResolver).delete(callID);
    }
  };
  waitForResult_fn = function(id2) {
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _idsToResolver).set(id2, (_, value, error) => {
        if (error == null) {
          resolve(this.serialization.deserialize(value, this));
        } else {
          reject(this.serialization.deserialize(error, this));
        }
      });
    });
    Object.defineProperty(promise, Symbol.asyncIterator, {
      async *value() {
        const result = await promise;
        Object.defineProperty(result, Symbol.asyncIterator, {
          value: () => result
        });
        yield* result;
      }
    });
    return promise;
  };
  function createThreadImports(handlerForImport, imported) {
    let call;
    if (imported == null) {
      if (typeof Proxy !== "function") {
        throw new Error(\`You must pass an array of callable methods in environments without Proxies.\`);
      }
      const cache = /* @__PURE__ */ new Map();
      call = new Proxy({}, {
        get(_target, property) {
          if (cache.has(property)) {
            return cache.get(property);
          }
          const handler = handlerForImport(property);
          cache.set(property, handler);
          return handler;
        }
      });
    } else {
      call = {};
      for (const method of imported) {
        Object.defineProperty(call, method, {
          value: handlerForImport(method),
          writable: false,
          configurable: true,
          enumerable: true
        });
      }
    }
    return call;
  }
  function missingThreadFunction() {
    throw new Error(\`You attempted to call a function that is not stored. It may have already been released.\`);
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/shared.mjs
  var CHECK_MESSAGE = "quilt.threads.ping";
  var RESPONSE_MESSAGE = "quilt.threads.pong";

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/window/ThreadNestedWindow.mjs
  function nestedWindowToThreadTarget(parent, {
    targetOrigin = "*"
  } = {}) {
    const ready = () => {
      const respond = () => parent.postMessage(RESPONSE_MESSAGE, targetOrigin);
      self.addEventListener("message", ({
        data,
        source
      }) => {
        if (source !== parent) return;
        if (data === CHECK_MESSAGE) respond();
      });
      respond();
    };
    if (document.readyState === "complete") {
      ready();
    } else {
      document.addEventListener("readystatechange", () => {
        if (document.readyState === "complete") {
          ready();
        }
      });
    }
    return {
      send(message, transfer) {
        return parent.postMessage(message, targetOrigin, transfer);
      },
      listen(listen, {
        signal
      }) {
        self.addEventListener("message", (event) => {
          if (event.data === CHECK_MESSAGE) return;
          listen(event.data);
        }, {
          signal
        });
      }
    };
  }

  // ../../node_modules/.pnpm/@quilted+threads@3.1.3_@preact+signals-core@1.10.0/node_modules/@quilted/threads/build/esm/threads/ThreadNestedIframe.mjs
  var ThreadNestedIframe = class extends Thread {
    constructor({
      parent = globalThis.parent,
      targetOrigin = "*",
      ...options
    } = {}) {
      if (typeof self === "undefined" || parent == null) {
        throw new Error("You are not inside an iframe, because there is no parent window.");
      }
      super(nestedWindowToThreadTarget(parent, {
        targetOrigin
      }), options);
      this.parent = parent;
    }
  };

  // scripts/iframe-entry.js
  new ThreadNestedIframe({
    exports: {
      async render(options, receiver, hostApi) {
        if (options.remoteElements) {
          options.remoteElements.forEach((def) => {
            if (customElements.get(def.tagName)) return;
            const remoteElement = class extends RemoteElement {
              static get remoteAttributes() {
                return def.remoteAttributes || [];
              }
              static get remoteEvents() {
                return def.remoteEvents || [];
              }
            };
            Object.defineProperty(remoteElement, "name", {
              value: \`Remote\${def.tagName.replace(/(^w|-w)/g, (c) => c.replace("-", "").toUpperCase())}\`
            });
            customElements.define(def.tagName, remoteElement);
          });
        }
        const root = document.querySelector("#root");
        const observer = new RemoteMutationObserver(receiver);
        observer.observe(root);
        const { code } = options;
        if (code && root) {
          try {
            const scriptFunction = new Function("root", "console", code);
            scriptFunction(root, console);
          } catch (e) {
            console.error("Error executing remote script:", e);
          }
        }
      }
    }
  });
})();

  <\/script>
</body>
</html>`, ae = 1, le = 2, Te = 3, ce = 4, ge = 5, de = Symbol.for("quilt.threads.serialize"), tt = Symbol.for("quilt.threads.transferable");
class rt extends AbortController {
  constructor(...e) {
    super();
    const t = e.find((n) => n.aborted);
    if (t)
      this.abort(t.reason);
    else {
      const n = (o) => this.abort(o.target.reason), i = {
        signal: this.signal
      };
      for (const o of e)
        o.addEventListener("abort", n, i);
    }
  }
}
class ue extends Error {
  constructor() {
    super("You attempted to call a function on a closed thread.");
  }
}
let nt = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function Re(r = 21) {
  let e = "", t = crypto.getRandomValues(new Uint8Array(r));
  for (let n = 0; n < r; n++) e += nt[63 & t[n]];
  return e;
}
var C, N, D, F, q, we;
class ot {
  constructor() {
    T(this, q);
    T(this, C, /* @__PURE__ */ new Map());
    T(this, N, /* @__PURE__ */ new Map());
    T(this, D, /* @__PURE__ */ new Map());
    T(this, F, /* @__PURE__ */ new WeakMap());
  }
  get(e) {
    return _(this, N).get(e);
  }
  release(e) {
    const t = _(this, N).get(e);
    return t && (_(this, N).delete(e), _(this, C).delete(t)), !!t;
  }
  serialize(e) {
    let t = _(this, C).get(e);
    return t == null && (t = Re(), _(this, C).set(e, t), _(this, N).set(t, e)), t;
  }
  deserialize(e, t) {
    var i, o;
    let n = (i = _(this, D).get(e)) == null ? void 0 : i.deref();
    return n || (n = (...a) => {
      if (!_(this, D).has(e))
        throw new Error("You attempted to call a function that was already revoked.");
      return t.call((p, d, f) => {
        t.messages.send([Te, p, e, d], f);
      }, a);
    }, (o = b(this, q, we).call(this, t)) == null || o.register(n, e), _(this, D).set(e, new WeakRef(n)), n);
  }
}
C = new WeakMap(), N = new WeakMap(), D = new WeakMap(), F = new WeakMap(), q = new WeakSet(), we = function(e) {
  let t = _(this, F).get(e);
  if (!(typeof FinalizationRegistry > "u"))
    return t || (t = new FinalizationRegistry((n) => {
      e.messages.send([ge, n]);
    }), _(this, F).set(e, t)), t;
};
function it(r) {
  return r != null && (Symbol.asyncIterator in r || Symbol.iterator in r) && typeof r.next == "function";
}
function pe(r) {
  if (r == null || typeof r != "object") return !1;
  const e = Object.getPrototypeOf(r);
  return e == null || e === Object.prototype;
}
const K = "_@f", me = "_@i";
var z, L, v, H, P;
class st {
  constructor(e) {
    T(this, v);
    T(this, z);
    T(this, L);
    G(this, z, e == null ? void 0 : e.serialize), G(this, L, e == null ? void 0 : e.deserialize);
  }
  /**
   * Serializes a value into a structured cloning-compatible format that can be transferred between threads.
   */
  serialize(e, t, n) {
    return b(this, v, H).call(this, e, t, n);
  }
  /**
   * Deserializes a structured cloning-compatible value from another thread.
   */
  deserialize(e, t) {
    return b(this, v, P).call(this, e, t);
  }
}
z = new WeakMap(), L = new WeakMap(), v = new WeakSet(), H = function(e, t, n, i = /* @__PURE__ */ new Map(), o = !1) {
  if (e == null) return e;
  if (i.has(e)) return i.get(e);
  if (i.set(e, void 0), typeof e == "object") {
    if (_(this, z) && !o) {
      const d = _(this, z).call(this, e, (f) => b(this, v, H).call(this, f, t, n, i, !0), t, n);
      if (d !== void 0)
        return i.set(e, d), d;
    }
    if (e[tt])
      return n == null || n.push(e), i.set(e, e), e;
    const a = (d) => b(this, v, H).call(this, d, t, n, i);
    if (typeof e[de] == "function") {
      const d = e[de]({
        serialize: a
      });
      return i.set(e, d), d;
    }
    if (Array.isArray(e)) {
      const d = e.map((f) => a(f));
      return i.set(e, d), d;
    }
    if (e instanceof Map) {
      const d = [...e.entries()].map(([s, c]) => [a(s), a(c)]), f = new Map(d);
      return i.set(e, f), f;
    }
    if (e instanceof Set) {
      const d = [...e].map((s) => a(s)), f = new Set(d);
      return i.set(e, f), f;
    }
    const p = it(e);
    if (pe(e) || p) {
      const d = {};
      for (const f of Object.keys(e))
        d[f] = a(e[f]);
      return p && (d.next ?? (d.next = a(e.next.bind(e))), d.return ?? (d.return = a(e.return.bind(e))), d.throw ?? (d.throw = a(e.throw.bind(e))), d[me] = !0), i.set(e, d), d;
    }
  }
  if (typeof e == "function") {
    const a = t.functions.serialize(e, t, n), p = {
      [K]: a
    };
    return i.set(e, p), p;
  }
  return i.set(e, e), e;
}, P = function(e, t, n = !1) {
  if (e == null) return e;
  if (typeof e == "object") {
    if (_(this, L) && !n) {
      const o = _(this, L).call(this, e, (a) => b(this, v, P).call(this, a, t, !0), t);
      if (o !== void 0)
        return o;
    }
    if (e == null)
      return e;
    if (Array.isArray(e))
      return e.map((o) => b(this, v, P).call(this, o, t));
    if (e instanceof Map)
      return new Map([...e].map(([o, a]) => [b(this, v, P).call(this, o, t), b(this, v, P).call(this, a, t)]));
    if (e instanceof Set)
      return new Set([...e].map((o) => b(this, v, P).call(this, o, t)));
    if (K in e)
      return t.functions.deserialize(e[K], t);
    if (!pe(e))
      return e;
    const i = {};
    for (const o of Object.keys(e))
      o === me ? i[Symbol.asyncIterator] = () => i : i[o] = b(this, v, P).call(this, e[o], t);
    return i;
  }
  return e;
};
var A, S, g, X, Pe, Q, Se;
class at {
  constructor(e, {
    imports: t,
    exports: n,
    functions: i = new ot(),
    serialization: o = new st(),
    signal: a
  } = {}) {
    T(this, g);
    T(this, A);
    T(this, S, /* @__PURE__ */ new Map());
    var p, d, f, s;
    this.messages = e, G(this, A, a ? new rt(a) : new AbortController()), this.exports = n ?? {}, this.imports = lt(b(this, g, Pe).bind(this), t), this.functions = i, this.serialization = o, (d = (p = this.functions).start) == null || d.call(p, this), (s = (f = this.serialization).start) == null || s.call(f, this), this.signal.addEventListener("abort", () => {
      for (const c of _(this, S).keys())
        b(this, g, Q).call(this, c, void 0, new ue());
      _(this, S).clear();
    }, {
      once: !0
    }), e.listen(async (c) => {
      if (!(Array.isArray(c) && typeof c[0] == "number"))
        return;
      const u = c;
      switch (u[0]) {
        case ae: {
          const [, m, h, R] = u, y = this.exports[h] ?? (() => {
            throw new Error(`No '${h}' method is exported from this thread`);
          });
          await b(this, g, X).call(this, y, R, (w, I, O) => {
            this.messages.send([le, m, w, I], O);
          });
          break;
        }
        case Te: {
          const [, m, h, R] = u, y = this.functions.get(h, this) ?? ct;
          await b(this, g, X).call(this, y, R, (w, I, O) => {
            this.messages.send([ce, m, w, I], O);
          });
          break;
        }
        case le:
        case ce: {
          b(this, g, Q).call(this, ...u.slice(1));
          break;
        }
        case ge: {
          const m = u[1];
          this.functions.release(m, this);
          break;
        }
      }
    }, {
      signal: this.signal
    });
  }
  /**
   * An object that exposes the methods that can be called on the paired thread.
   * This object will automatically encode and decode arguments and return values
   * as necessary.
   */
  /**
   * An object that exposes the methods that can be called on this thread by the
   * paired thread. To set these methods, pass the `exports` option when creating
   * a new `Thread`.
   */
  /**
   * An object that provides the message-passing interface that allows communication
   * to flow between environments.
   */
  /**
   * An object that manages how functions are proxied between threads.
   */
  /**
   * An object that manages how values are serialized and deserialized between threads.
   */
  /**
   * An `AbortSignal` that indicates whether the communication channel is still open.
   */
  get signal() {
    return _(this, A).signal;
  }
  /**
   * A boolean indicating whether the communication channel is still open.
   */
  get closed() {
    return _(this, A).signal.aborted;
  }
  /**
   * Closes the communication channel between the two threads. This will prevent
   * any further communication between the threads, and will clean up any memory
   * associated with in-progress communication. It will also reject any inflight
   * function calls between threads with a `ThreadClosedError`.
   */
  close() {
    _(this, A).abort();
  }
  /**
   * Requests that the thread provide the context needed to make a function
   * call between threads. You provide this method a function to call and the
   * unserialized arguments you wish to call it with, and the thread will call
   * the function you provided with a serialized call ID, the serialized arguments,
   * and any transferable objects that need to be passed between threads.
   */
  call(e, t) {
    if (this.closed)
      return Promise.reject(new ue());
    const n = [], i = this.serialization.serialize(t, this, n), o = Re(), a = b(this, g, Se).call(this, o);
    return e(o, i, n), a;
  }
}
A = new WeakMap(), S = new WeakMap(), g = new WeakSet(), X = async function(e, t, n) {
  try {
    const i = this.functions.call ? await this.functions.call(e, t, this) : await e(...this.serialization.deserialize(t, this)), o = [], a = this.serialization.serialize(i, this, o);
    n(a, void 0, o);
  } catch (i) {
    n(void 0, this.serialization.serialize(i, this));
  }
}, Pe = function(e) {
  return (...t) => {
    try {
      if (typeof e != "string" && typeof e != "number")
        throw new Error(`Can’t call a symbol method on a thread: ${e.toString()}`);
      return this.call((n, i, o) => {
        this.messages.send([ae, n, e, i], o);
      }, t);
    } catch (n) {
      return Promise.reject(n);
    }
  };
}, Q = function(...e) {
  const t = e[0], n = _(this, S).get(t);
  n && (n(...e), _(this, S).delete(t));
}, Se = function(e) {
  const t = new Promise((n, i) => {
    _(this, S).set(e, (o, a, p) => {
      p == null ? n(this.serialization.deserialize(a, this)) : i(this.serialization.deserialize(p, this));
    });
  });
  return Object.defineProperty(t, Symbol.asyncIterator, {
    async *value() {
      const n = await t;
      Object.defineProperty(n, Symbol.asyncIterator, {
        value: () => n
      }), yield* n;
    }
  }), t;
};
function lt(r, e) {
  let t;
  if (e == null) {
    if (typeof Proxy != "function")
      throw new Error("You must pass an array of callable methods in environments without Proxies.");
    const n = /* @__PURE__ */ new Map();
    t = new Proxy({}, {
      get(i, o) {
        if (n.has(o))
          return n.get(o);
        const a = r(o);
        return n.set(o, a), a;
      }
    });
  } else {
    t = {};
    for (const n of e)
      Object.defineProperty(t, n, {
        value: r(n),
        writable: !1,
        configurable: !0,
        enumerable: !0
      });
  }
  return t;
}
function ct() {
  throw new Error("You attempted to call a function that is not stored. It may have already been released.");
}
const dt = "quilt.threads.ping", fe = "quilt.threads.pong";
function ut(r, {
  targetOrigin: e = "*"
} = {}) {
  let t = !1;
  const n = function(a, p) {
    r.postMessage(a, e, p);
  }, i = new Promise((o) => {
    const a = new AbortController();
    globalThis.window.addEventListener("message", (p) => {
      p.source === r && p.data === fe && (t = !0, a.abort(), o());
    }, {
      signal: a.signal
    }), a.signal.addEventListener("abort", () => o(), {
      once: !0
    }), n(dt);
  });
  return {
    send(o, a) {
      return t ? n(o, a) : i.then(() => {
        if (t) return n(o, a);
      });
    },
    listen(o, {
      signal: a
    }) {
      self.addEventListener("message", (p) => {
        p.source === r && p.data !== fe && o(p.data);
      }, {
        signal: a
      });
    }
  };
}
class pt extends at {
  constructor(e, {
    targetOrigin: t = "*",
    ...n
  } = {}) {
    super(ut(e.contentWindow, {
      targetOrigin: t
    }), n), this.iframe = e;
  }
}
const Me = Y.forwardRef(({ content: r, children: e, ...t }, n) => /* @__PURE__ */ E("span", { ref: n, ...t, children: r || e }));
Me.displayName = "UIText";
const Ne = Y.forwardRef(({ label: r, onPress: e, onClick: t, children: n, ...i }, o) => /* @__PURE__ */ E(
  "button",
  {
    ref: o,
    onClick: (p) => {
      e && e(), t && t(p);
    },
    style: {
      padding: "8px 16px",
      backgroundColor: "#007bff",
      color: "white",
      border: "none",
      borderRadius: "4px",
      cursor: "pointer"
    },
    ...i,
    children: r || n
  }
));
Ne.displayName = "UIButton";
const Ae = Y.forwardRef(({ direction: r = "vertical", spacing: e = "8", align: t = "stretch", justify: n = "flex-start", children: i, ...o }, a) => /* @__PURE__ */ E(
  "div",
  {
    ref: a,
    style: {
      display: "flex",
      flexDirection: r === "horizontal" ? "row" : "column",
      gap: `${e}px`,
      alignItems: t,
      justifyContent: n
    },
    ...o,
    children: i
  }
));
Ae.displayName = "UIStack";
const Ie = Y.forwardRef(({ src: r, alt: e, width: t, height: n, children: i, ...o }, a) => /* @__PURE__ */ E(
  "img",
  {
    ref: a,
    src: r,
    alt: e,
    width: t,
    height: n,
    style: {
      maxWidth: "100%",
      height: "auto",
      borderRadius: "8px",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.1)"
    },
    ...o
  }
));
Ie.displayName = "UIImage";
const Oe = {
  name: "basic",
  elements: [
    {
      tagName: "ui-text",
      component: Me,
      propMapping: {
        content: "content"
      },
      eventMapping: {}
    },
    {
      tagName: "ui-button",
      component: Ne,
      propMapping: {
        label: "label"
      },
      eventMapping: {
        press: "onPress"
      }
    },
    {
      tagName: "ui-stack",
      component: Ae,
      propMapping: {
        direction: "direction",
        spacing: "spacing",
        align: "align",
        justify: "justify"
      },
      eventMapping: {}
    },
    {
      tagName: "ui-image",
      component: Ie,
      propMapping: {
        src: "src",
        alt: "alt",
        width: "width",
        height: "height"
      },
      eventMapping: {}
    }
  ]
}, mt = ({
  receiver: r
}) => {
  const e = k(null);
  return U(() => {
    if (e.current)
      return r.connect(e.current), () => {
        r.disconnect();
      };
  }, [r]), /* @__PURE__ */ E("div", { ref: e, "data-testid": "standard-dom-renderer-container" });
}, ft = ({
  resource: r,
  library: e,
  remoteElements: t = [],
  onUiAction: n
}) => {
  const i = k(null), o = k(null), a = Z(() => (r.mimeType || "").includes("flavor=react") ? "react" : "webcomponents", [r.mimeType]), p = `${e == null ? void 0 : e.name}-${a}`, { receiver: d, components: f } = Z(() => {
    switch (a) {
      case "react": {
        const c = new He(), l = e || Oe, u = /* @__PURE__ */ new Map();
        return l && l.elements.forEach((m) => {
          const h = Je(
            m.component
          );
          u.set(m.tagName, h);
        }), {
          receiver: c,
          components: u
        };
      }
      case "webcomponents":
      default:
        return {
          receiver: new qe(),
          components: null
        };
    }
  }, [r, e, t]);
  return U(() => {
    function c(l) {
      var u;
      if (i.current && l.source === i.current.contentWindow) {
        const m = l.data;
        if (!m)
          return;
        (u = n == null ? void 0 : n(m)) == null || u.catch((h) => {
          console.error(
            "Error handling UI action result in RemoteDomResource:",
            h
          );
        });
      }
    }
    return window.addEventListener("message", c), () => window.removeEventListener("message", c);
  }, [n]), U(() => {
    const c = o.current;
    return o.current = null, () => {
      c == null || c.close();
    };
  }, [p]), /* @__PURE__ */ ee(B, { children: [
    /* @__PURE__ */ E(
      "iframe",
      {
        ref: i,
        srcDoc: et,
        sandbox: "allow-scripts",
        style: { display: "none" },
        title: "Remote DOM Sandbox",
        onLoad: () => {
          const c = i.current;
          if (!c || o.current)
            return;
          const l = new pt(c);
          if (o.current = l, r.content && typeof r.content == "string" && (d != null && d.connection)) {
            const u = {
              code: r.content,
              remoteElements: t,
              useReactRenderer: a === "react",
              componentLibrary: e == null ? void 0 : e.name
            };
            l.imports.render(u, d.connection).catch((m) => console.error("Error calling remote render:", m));
          }
        }
      },
      p
    ),
    a === "react" && f ? /* @__PURE__ */ E(Qe, { receiver: d, components: f }) : /* @__PURE__ */ E(mt, { receiver: d })
  ] });
};
function ht(r) {
  var e;
  if (r.contentType)
    return r.contentType;
  if (r.mimeType === "text/html")
    return "rawHtml";
  if (r.mimeType === "text/uri-list")
    return "externalUrl";
  if ((e = r.mimeType) != null && e.startsWith("application/vnd.mcp-ui.remote-dom"))
    return "remoteDom";
}
const vt = (r) => {
  const {
    resource: e,
    onUiAction: t,
    style: n,
    iframeProps: i,
    supportedContentTypes: o,
    library: a
  } = r, p = ht(e);
  if (o && p && !o.includes(p))
    return /* @__PURE__ */ ee("p", { className: "text-red-500", children: [
      "Unsupported content type: ",
      p,
      "."
    ] });
  switch (p) {
    case "rawHtml":
    case "externalUrl":
      return /* @__PURE__ */ E(
        he,
        {
          resource: e,
          onUiAction: t,
          style: n,
          iframeProps: i
        }
      );
    case "remoteDom":
      return /* @__PURE__ */ E(
        ft,
        {
          resource: e,
          onUiAction: t,
          library: a || Oe
        }
      );
    default:
      return /* @__PURE__ */ E("p", { className: "text-red-500", children: "Unsupported resource type." });
  }
}, yt = {
  tagName: "ui-card"
}, Tt = {
  tagName: "ui-button",
  remoteAttributes: ["label"],
  remoteEvents: ["click", "press"]
}, gt = {
  tagName: "ui-text",
  remoteAttributes: ["content"]
}, Rt = {
  tagName: "ui-stack",
  remoteAttributes: ["direction", "spacing", "align", "justify"]
}, wt = {
  tagName: "ui-image",
  remoteAttributes: ["src", "alt", "width", "height"]
};
export {
  he as HtmlResource,
  ft as RemoteDomResource,
  vt as ResourceRenderer,
  Oe as basicComponentLibrary,
  Tt as remoteButtonDefinition,
  yt as remoteCardDefinition,
  wt as remoteImageDefinition,
  Rt as remoteStackDefinition,
  gt as remoteTextDefinition
};
