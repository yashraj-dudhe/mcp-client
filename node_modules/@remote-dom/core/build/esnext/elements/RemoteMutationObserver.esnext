import { remoteId, disconnectRemoteNode, connectRemoteNode, serializeRemoteNode, REMOTE_IDS } from './internals.esnext';
import { MUTATION_TYPE_INSERT_CHILD, MUTATION_TYPE_UPDATE_TEXT, MUTATION_TYPE_UPDATE_PROPERTY, ROOT_ID, MUTATION_TYPE_REMOVE_CHILD } from '../constants.esnext';

class RemoteMutationObserver extends MutationObserver {
  constructor(connection) {
    super((records) => {
      const addedNodes = [];
      const remoteRecords = [];
      for (const record of records) {
        const targetId = remoteId(record.target);
        if (record.type === "childList") {
          const position = record.previousSibling ? indexOf(record.previousSibling, record.target.childNodes) + 1 : 0;
          record.removedNodes.forEach((node) => {
            disconnectRemoteNode(node);
            remoteRecords.push([
              MUTATION_TYPE_REMOVE_CHILD,
              targetId,
              position
            ]);
          });
          record.addedNodes.forEach((node, index) => {
            if (addedNodes.some((addedNode) => {
              return addedNode === node || addedNode.contains(node);
            })) {
              return;
            }
            addedNodes.push(node);
            connectRemoteNode(node, connection);
            remoteRecords.push([
              MUTATION_TYPE_INSERT_CHILD,
              targetId,
              serializeRemoteNode(node),
              position + index
            ]);
          });
        } else if (record.type === "characterData") {
          remoteRecords.push([
            MUTATION_TYPE_UPDATE_TEXT,
            targetId,
            record.target.textContent ?? ""
          ]);
        } else if (record.type === "attributes" && record.attributeName != null && record.target instanceof Element && !record.target.tagName.includes("-")) {
          remoteRecords.push([
            MUTATION_TYPE_UPDATE_PROPERTY,
            targetId,
            record.attributeName,
            record.target.getAttribute(record.attributeName)
          ]);
        }
      }
      connection.mutate(remoteRecords);
    });
    this.connection = connection;
  }
  /**
   * Starts watching changes to the element, and communicates changes to the
   * host environment. By default, this method will also communicate any initial
   * children of the element to the host environment.
   */
  observe(target, options) {
    REMOTE_IDS.set(target, ROOT_ID);
    if (options?.initial !== false && target.childNodes.length > 0) {
      const records = [];
      for (let i = 0; i < target.childNodes.length; i++) {
        const node = target.childNodes[i];
        connectRemoteNode(node, this.connection);
        records.push([
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          serializeRemoteNode(node),
          i
        ]);
      }
      this.connection.mutate(records);
    }
    super.observe(target, {
      subtree: true,
      childList: true,
      attributes: true,
      characterData: true,
      ...options
    });
  }
}
function indexOf(node, list) {
  for (let i = 0; i < list.length; i++) {
    if (list[i] === node) return i;
  }
  return -1;
}

export { RemoteMutationObserver };
