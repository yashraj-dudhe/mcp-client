import { MUTATION_TYPE_UPDATE_PROPERTY, UPDATE_PROPERTY_TYPE_PROPERTY, UPDATE_PROPERTY_TYPE_ATTRIBUTE, UPDATE_PROPERTY_TYPE_EVENT_LISTENER } from '../constants.esnext';

const REMOTE_CONNECTIONS = /* @__PURE__ */ new WeakMap();
function remoteConnection(node) {
  return REMOTE_CONNECTIONS.get(node);
}
const REMOTE_IDS = /* @__PURE__ */ new WeakMap();
let id = 0;
function remoteId(node) {
  let remoteID = REMOTE_IDS.get(node);
  if (remoteID == null) {
    remoteID = String(id++);
    REMOTE_IDS.set(node, remoteID);
  }
  return remoteID;
}
const REMOTE_PROPERTIES = /* @__PURE__ */ new WeakMap();
function remoteProperties(node) {
  return REMOTE_PROPERTIES.get(node);
}
const REMOTE_ATTRIBUTES = /* @__PURE__ */ new WeakMap();
function remoteAttributes(node) {
  let attributes = REMOTE_ATTRIBUTES.get(node);
  if (attributes != null) return attributes;
  if (!(node instanceof Element) || node.tagName.includes("-"))
    return void 0;
  attributes = {};
  for (const { name, value } of node.attributes) {
    attributes[name] = value;
  }
  return attributes;
}
const REMOTE_EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
function remoteEventListeners(node) {
  return REMOTE_EVENT_LISTENERS.get(node);
}
function updateRemoteElementProperty(node, property, value) {
  let properties = REMOTE_PROPERTIES.get(node);
  if (properties == null) {
    properties = {};
    REMOTE_PROPERTIES.set(node, properties);
  }
  if (properties[property] === value) return;
  properties[property] = value;
  const connection = REMOTE_CONNECTIONS.get(node);
  if (connection == null) return;
  connection.mutate([
    [
      MUTATION_TYPE_UPDATE_PROPERTY,
      remoteId(node),
      property,
      value,
      UPDATE_PROPERTY_TYPE_PROPERTY
    ]
  ]);
}
function updateRemoteElementAttribute(node, attribute, value) {
  let attributes = REMOTE_ATTRIBUTES.get(node);
  if (attributes == null) {
    attributes = {};
    REMOTE_ATTRIBUTES.set(node, attributes);
  }
  if (attributes[attribute] === value) return;
  if (value == null) {
    delete attributes[attribute];
  } else {
    attributes[attribute] = String(value);
  }
  const connection = REMOTE_CONNECTIONS.get(node);
  if (connection == null) return;
  connection.mutate([
    [
      MUTATION_TYPE_UPDATE_PROPERTY,
      remoteId(node),
      attribute,
      value,
      UPDATE_PROPERTY_TYPE_ATTRIBUTE
    ]
  ]);
}
function updateRemoteElementEventListener(node, event, listener) {
  let eventListeners = REMOTE_EVENT_LISTENERS.get(node);
  if (eventListeners == null) {
    eventListeners = {};
    REMOTE_EVENT_LISTENERS.set(node, eventListeners);
  }
  if (eventListeners[event] === listener) return;
  if (listener == null) {
    delete eventListeners[event];
  } else {
    eventListeners[event] = listener;
  }
  const connection = REMOTE_CONNECTIONS.get(node);
  if (connection == null) return;
  connection.mutate([
    [
      MUTATION_TYPE_UPDATE_PROPERTY,
      remoteId(node),
      event,
      listener,
      UPDATE_PROPERTY_TYPE_EVENT_LISTENER
    ]
  ]);
}
function connectRemoteNode(node, connection) {
  const existingConnection = REMOTE_CONNECTIONS.get(node);
  if (existingConnection === connection) return;
  REMOTE_CONNECTIONS.set(node, connection);
  if (node.childNodes) {
    for (let i = 0; i < node.childNodes.length; i++) {
      connectRemoteNode(node.childNodes[i], connection);
    }
  }
}
function disconnectRemoteNode(node) {
  const existingConnection = REMOTE_CONNECTIONS.get(node);
  if (existingConnection == null) return;
  REMOTE_CONNECTIONS.delete(node);
  if (node.childNodes) {
    for (let i = 0; i < node.childNodes.length; i++) {
      disconnectRemoteNode(node.childNodes[i]);
    }
  }
}
function serializeRemoteNode(node) {
  const { nodeType } = node;
  switch (nodeType) {
    // Element
    case 1: {
      return {
        id: remoteId(node),
        type: nodeType,
        element: node.localName,
        properties: cloneMaybeObject(remoteProperties(node)),
        attributes: cloneMaybeObject(remoteAttributes(node)),
        eventListeners: cloneMaybeObject(remoteEventListeners(node)),
        children: Array.from(node.childNodes).map(serializeRemoteNode)
      };
    }
    // TextNode
    case 3:
    // Comment
    // eslint-disable-next-line no-fallthrough
    case 8: {
      return {
        id: remoteId(node),
        type: nodeType,
        data: node.data
      };
    }
    default: {
      throw new Error(
        `Cannot serialize node of type ${node.nodeType} (${typeof node.nodeType})`
      );
    }
  }
}
function cloneMaybeObject(maybeObject) {
  return maybeObject ? { ...maybeObject } : void 0;
}
function callRemoteElementMethod(node, method, ...args) {
  const id2 = REMOTE_IDS.get(node);
  const connection = REMOTE_CONNECTIONS.get(node);
  if (id2 == null || connection == null) {
    throw new Error(`Cannot call method ${method} on an unconnected node`);
  }
  return connection.call(id2, method, ...args);
}

export { REMOTE_ATTRIBUTES, REMOTE_CONNECTIONS, REMOTE_EVENT_LISTENERS, REMOTE_IDS, REMOTE_PROPERTIES, callRemoteElementMethod, connectRemoteNode, disconnectRemoteNode, remoteAttributes, remoteConnection, remoteEventListeners, remoteId, remoteProperties, serializeRemoteNode, updateRemoteElementAttribute, updateRemoteElementEventListener, updateRemoteElementProperty };
