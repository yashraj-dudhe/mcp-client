import { CHILD, NEXT, PARENT, PREV } from './constants.esnext';
import { isElementNode } from './shared.esnext';

const ELEMENT_SELECTOR_TEST = /[a-z]/;
function querySelector(within, selector) {
  const parts = parseSelector(selector);
  let result = null;
  const child = within[CHILD];
  if (child && parts[0].matchers.length) {
    walkNodesForSelector(child, parts, (node) => {
      result = node;
      return false;
    });
  }
  return result;
}
function querySelectorAll(within, selector) {
  const parts = parseSelector(selector);
  const results = [];
  const child = within[CHILD];
  if (child && parts[0].matchers.length) {
    walkNodesForSelector(child, parts, (node) => {
      results.push(node);
    });
  }
  return results;
}
function parseSelector(selector) {
  let part = { combinator: 4 /* Inner */, matchers: [] };
  const parts = [part];
  const tokenizer = /\s*?([>\s+~]?)\s*?(?:(?:\[\s*([^\]=]+)(?:=(['"])(.*?)\3)?\s*\])|([#.]?)([^\s#.[>:]+)|:(\w+)(?:\((.*?)\))?)/gi;
  let token;
  while (token = tokenizer.exec(selector)) {
    if (token[1]) {
      if (token[1] === ">") part.combinator = 1 /* Child */;
      else if (token[1] === "+") part.combinator = 3 /* Adjacent */;
      else if (token[1] === "~") part.combinator = 2 /* Sibling */;
      else part.combinator = 0 /* Descendant */;
      part = { combinator: 4 /* Inner */, matchers: [] };
      parts.push(part);
    }
    let type = 0 /* Unknown */;
    if (token[2]) {
      type = 4 /* Attribute */;
    } else if (token[5]) {
      type = token[5] === "#" ? 2 /* Id */ : 3 /* Class */;
    } else if (token[7]) {
      type = token[8] == null ? 5 /* Pseudo */ : 6 /* Function */;
    } else if (token[6] && ELEMENT_SELECTOR_TEST.test(token[6])) {
      type = 1 /* Element */;
    }
    part.matchers.push({
      type,
      name: token[2] || token[6] || token[7],
      value: token[4] ?? token[6] ?? token[8]
    });
  }
  return parts;
}
function matchesSelector(element, selector) {
  const parsed = parseSelector(selector);
  let part;
  while (part = parsed.pop()) {
    if (!matchesSelectorPart(element, part)) return false;
  }
  return true;
}
function walkNodesForSelector(node, parts, callback) {
  if (isElementNode(node)) {
    if (matchesSelectorRecursive(node, parts)) {
      if (callback(node) === false) return false;
    }
    const child = node[CHILD];
    if (child && walkNodesForSelector(child, parts, callback) === false) {
      return false;
    }
  }
  const next = node[NEXT];
  if (next && walkNodesForSelector(next, parts, callback) === false) {
    return false;
  }
  return true;
}
function matchesSelectorRecursive(element, parts) {
  const { combinator, matchers } = parts[parts.length - 1];
  if (combinator === 4 /* Inner */) {
    if (!matchesSelectorMatcher(element, matchers)) return false;
    const pp = parts.slice(0, -1);
    return pp.length === 0 || matchesSelectorRecursive(element, pp);
  }
  const link = combinator === 1 /* Child */ || combinator === 0 /* Descendant */ ? PARENT : PREV;
  let ref = element[link];
  if (!ref || !matchesSelectorMatcher(ref, matchers)) {
    return false;
  }
  if (combinator === 0 /* Descendant */ || combinator === 2 /* Sibling */) {
    while (ref = ref[link]) {
      if (matchesSelectorMatcher(ref, matchers)) {
        const pp = parts.slice(0, -1);
        if (pp.length === 0) return true;
        if (matchesSelectorRecursive(element, pp)) return true;
      }
    }
  }
  return false;
}
function matchesSelectorPart(element, { combinator, matchers }) {
  if (combinator === 4 /* Inner */) {
    return matchesSelectorMatcher(element, matchers);
  }
  const link = combinator === 1 /* Child */ || combinator === 0 /* Descendant */ ? PARENT : PREV;
  let ref = element[link];
  if (!ref || !matchesSelectorMatcher(ref, matchers)) {
    return false;
  }
  if (combinator === 0 /* Descendant */ || combinator === 2 /* Sibling */) {
    while (ref = ref[link]) {
      if (matchesSelectorMatcher(ref, matchers)) return true;
    }
  }
  return false;
}
function matchesSelectorMatcher(element, matcher) {
  if (!element) return false;
  if (Array.isArray(matcher)) {
    for (const single of matcher) {
      if (matchesSelectorMatcher(element, single) === false) return false;
    }
    return true;
  }
  const { type, name, value } = matcher;
  switch (type) {
    case 1 /* Element */:
      return element.localName === name;
    case 2 /* Id */:
      return element.getAttribute("id") === name;
    case 3 /* Class */:
      return element.getAttribute("class") === name;
    case 4 /* Attribute */:
      return value == null ? element.hasAttribute(name) : element.getAttribute(name) === value;
    case 5 /* Pseudo */:
      switch (name) {
        default:
          throw Error(`Pseudo :${name} not implemented`);
      }
    case 6 /* Function */:
      switch (name) {
        case "has":
          return matchesSelector(element, value || "");
        default:
          throw Error(`Function :${name}(${value}) not implemented`);
      }
  }
  return false;
}

export { parseSelector, querySelector, querySelectorAll };
