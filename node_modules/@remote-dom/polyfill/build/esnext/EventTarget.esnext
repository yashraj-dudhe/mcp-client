import { LISTENERS, OWNER_DOCUMENT, HOOKS, PATH } from './constants.esnext';
import { fireEvent, EventPhase, CAPTURE_MARKER } from './Event.esnext';

const ONCE_LISTENERS = Symbol("onceListeners");
class EventTarget {
  [LISTENERS] = void 0;
  [ONCE_LISTENERS] = void 0;
  /**
   * Property set by entities that extend this class that are part of the DOM tree.
   * @internal
   */
  [OWNER_DOCUMENT] = void 0;
  addEventListener(type, listener, options) {
    if (listener == null) return;
    const capture = options === true || options && options.capture === true;
    const once = typeof options === "object" && options.once === true;
    const signal = typeof options === "object" ? options.signal : void 0;
    const key = `${type}${capture ? CAPTURE_MARKER : ""}`;
    let normalizedListener = listener;
    if (once) {
      normalizedListener = function normalizedListener2(...args) {
        this.removeEventListener(type, listener, options);
        return typeof listener === "object" ? listener.handleEvent(...args) : listener.call(this, ...args);
      };
      let onceListeners = this[ONCE_LISTENERS];
      if (!onceListeners) {
        onceListeners = /* @__PURE__ */ new WeakMap();
        this[ONCE_LISTENERS] = onceListeners;
      }
      onceListeners.set(listener, normalizedListener);
    }
    let listeners = this[LISTENERS];
    if (!listeners) {
      listeners = /* @__PURE__ */ new Map();
      this[LISTENERS] = listeners;
    }
    let list = listeners.get(key);
    if (!list) {
      list = /* @__PURE__ */ new Set();
      listeners.set(key, list);
    }
    if (list.has(normalizedListener)) return;
    signal?.addEventListener(
      "abort",
      () => {
        removeEventListener.call(this, type, listener, options);
      },
      { once: true }
    );
    list.add(normalizedListener);
    this[OWNER_DOCUMENT]?.defaultView[HOOKS].addEventListener?.(
      this,
      type,
      listener,
      options
    );
  }
  removeEventListener(type, listener, options) {
    return removeEventListener.call(this, type, listener, options);
  }
  // function isChildNode(node: EventTarget): node is ChildNode {
  //   return PARENT in node;
  // }
  dispatchEvent(event) {
    const path = [];
    let target = this;
    while (target != null) {
      path.push(target);
      target = target.parentNode;
    }
    event.target = this;
    event.srcElement = this;
    event[PATH] = path;
    for (let i = path.length; i--; ) {
      fireEvent(event, path[i], EventPhase.CAPTURING_PHASE);
      if (event.cancelBubble) return event.defaultPrevented;
    }
    const bubblePath = event.bubbles ? path : path.slice(0, 1);
    for (let i = 0; i < bubblePath.length; i++) {
      fireEvent(event, bubblePath[i], EventPhase.BUBBLING_PHASE);
      if (event.cancelBubble) return event.defaultPrevented;
    }
    return event.defaultPrevented;
  }
}
function removeEventListener(type, listener, options) {
  if (listener == null) return;
  const onceListeners = this[ONCE_LISTENERS];
  const normalizedListener = onceListeners?.get(listener) ?? listener;
  onceListeners?.delete(listener);
  const capture = options === true || options && options.capture === true;
  const key = `${type}${capture ? CAPTURE_MARKER : ""}`;
  const list = this[LISTENERS]?.get(key);
  if (list) {
    const deleted = list.delete(normalizedListener);
    if (deleted) {
      this[OWNER_DOCUMENT]?.defaultView[HOOKS].removeEventListener?.(
        this,
        type,
        listener,
        options
      );
    }
  }
}

export { EventTarget };
